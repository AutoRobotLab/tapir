#include "VrepHelper.hpp"

#include <vector>
#include <geometry_msgs/Point.h>

/** 
 * ROS service files actually from package vrep_common
 * However, vrep_common headers cannot be included
 * because vrep_common is a rosbuild package
 * Therefore they are generated by this package
 */
#include "abt/simRosCopyPasteObjects.h" 
#include "abt/simRosGetObjectHandle.h"
#include "abt/simRosSetObjectPosition.h"
#include "abt/simRosStartSimulation.h"
#include "abt/simRosStopSimulation.h"
#include "abt/simRosGetObjectPose.h"

VrepHelper::VrepHelper():
    running_(false)
{
}

VrepHelper::VrepHelper(ros::NodeHandle *node):
    running_(false)
{
    setRosNode(node);
}

void VrepHelper::setRosNode(ros::NodeHandle *node) {
    node_ = node;
    startClient_ = node_->serviceClient<abt::simRosStartSimulation>("vrep/simRosStartSimulation");
    stopClient_ = node_->serviceClient<abt::simRosStopSimulation>("vrep/simRosStopSimulation");
    copyClient_ = node_->serviceClient<abt::simRosCopyPasteObjects>("vrep/simRosCopyPasteObjects");
    handleClient_ = node_->serviceClient<abt::simRosGetObjectHandle>("vrep/simRosGetObjectHandle");
    moveClient_ = node_->serviceClient<abt::simRosSetObjectPosition>("vrep/simRosSetObjectPosition");
    poseClient_ = node_->serviceClient<abt::simRosGetObjectPose>("vrep/simRosGetObjectPose");
    infoSub_ = node_->subscribe("/vrep/info", 1, &VrepHelper::infoCallback, this);
}

/**
 * Attempt to start or unpause VREP simulation 
 * VREP must already be running. Returns true if success
 */
bool VrepHelper::start() {
    abt::simRosStartSimulation startSrv;
    startClient_.call(startSrv);
    return startSrv.response.result != -1;
}

/** Attempt to stop VREP simulation. Returns true if success */
bool VrepHelper::stop() {
    abt::simRosStopSimulation stopSrv;
    stopClient_.call(stopSrv);
    return stopSrv.response.result != -1;
}

/**
 * Returns the handle of an object in VREP simulation
 * Returns -1 if failure
 */
long VrepHelper::getHandle(std::string name) {
	abt::simRosGetObjectHandle handleSrv;
	handleSrv.request.objectName = name;
    handleClient_.call(handleSrv);
    return handleSrv.response.handle;
}

/**
 * Move an object in VREP simulation to a new position
 * Returns true if success.
 */
bool VrepHelper::moveObject(std::string name, float x, float y, float z) {
	long handle = getHandle(name);
    return moveObject(handle, x, y, z);
}

/**
 * Move an object by handle in VREP simulation to
 * a new position. Returns true if success.
 */
bool VrepHelper::moveObject(long handle, float x, float y, float z) {
	geometry_msgs::Point msg;
	msg.x = x;
    msg.y = y;
    msg.z = z;
    abt::simRosSetObjectPosition moveSrv;
    moveSrv.request.handle = handle;
    moveSrv.request.relativeToObjectHandle = -1;
    moveSrv.request.position = msg;
    moveClient_.call(moveSrv);
    return moveSrv.response.result != -1;
}

/** Copy an object in VREP simulation. Returns handle of copied object. */
long VrepHelper::copyObject(long handle) {
    std::vector<int> handles;
    handles.push_back(handle);
    abt::simRosCopyPasteObjects copySrv;
    copySrv.request.objectHandles = handles;
    copyClient_.call(copySrv);
    return copySrv.response.newObjectHandles[0];
}

/** Returns true iff VREP simulation is not stopped */
bool VrepHelper::isRunning() {
    ros::spinOnce();
    return running_;
}

// Get the pose of an object in VREP simulation
geometry_msgs::PoseStamped VrepHelper::getPose(long handle) {
    abt::simRosGetObjectPose poseSrv;
    poseSrv.request.handle = handle;
    poseSrv.request.relativeToObjectHandle = -1;
    poseClient_.call(poseSrv);
    return poseSrv.response.pose;
}

/** Callback for /vrep/info topic */
void VrepHelper::infoCallback(const abt::VrepInfo::ConstPtr& msg) {

    // Set running_ true iff simulation is not stopped/paused
    // bit0 set: simulation not stopped
    // bit1 set: simulation paused
    int status = msg->simulatorState.data;
    running_ = status & 0b1 == 1 && status & 0b10 == 2;
}

