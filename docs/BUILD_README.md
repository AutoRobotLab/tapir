Custom non-recursive Make system {#build-system}
================================================

Introduction
------------
The build system uses a non-recursive approach with GNU make, similar to the
one documented in the paper
[Recursive Make Considered Harmful](http://aegis.sourceforge.net/auug97.pdf)
by Peter Miller, and adapting some Makefile code from
[here](http://evbergen.home.xs4all.nl/nonrecursive-make.html).

The paper describes many advantages to non-recursive Make; in short, it results
in a cleaner and more robust dependency tree, and it means that the code can
quite easily be compiled in parallel.

The system used here adds two key conveniences to the aforementioned system:
- Improved readability by moving standard code, especially the recursion,
	into template files wihin the .make directory.
	The recursion is located in [stack.mk].
- The ability to call make from any child folder and have it behave the way
	you would expect it to if that child folder were the root.

General usage
-------------
Global configuration settings are set in the [root Makefile][Makefile],
and then individual modules can each be configured via the Makefile in their
own subfolder (e.g. [this][Makefile_src]).

The subfolder Makefiles should work more or less like normal Makefiles,
although it is processed relative to the root folder, which means that any paths
should be relative to the root - the variable $(d) is provided as shorthand for
the relative path of the current module w.r.t. the root.

Each module is also required to define two variables that are used for the
recursive processing:
- MODULE_NAME: The module name; should be a unique identifier. This is used
    for generating intermediate targets for each specific module.
- CHILD_FOLDERS: The subdirectories that are required to be processed.

However, in order to mainain consistency with the rest of the build system,
particularly with regards to build modes (release vs. debug) and with regards
to the structure of the build output directories (e.g. builds/release
and builds/debug), it is best to use the provided templates to automatically
generate most of the rules. Refer to
[the Makefile in the src folder][Makefile_src] for a simple example, or read
the next section for greater depth.

Makefile templates
------------------
The key rules that do most of the work are located in
[template.mk][template.mk], which detects .cpp source files and includes
a default .cpp -> .o recipe, as well as automatic dependency handling.

To provide rules on how to build the module as a whole rather than implicitly
via other modules that depend on it, you need to add the targets you want as
prerequisites for the phony build targets. For example,
build-solver
is the target that builds the entire "solver" module.

The simplest way to define the build pattern for a module is to simply build
every individual object file - the rule for this is given in
[build.mk][build.mk].

The solver code is currently set to build into an archive called "libabt.a";
the rules to do this are defined in
[the "solver" Makefile][Makefile_solver]
As you can see there, the rule defines all of the files that make up this
library in terms of the automatic OBJS\_[module] variables generated by
the template code.

Problem templates
-----------------
A more complex example is the build template used for each individual
problem, which is located in [problem-template.mk][problem-template.mk].
Its purpose is to defines recipes for the "solve" and "simulate" executables,
which are the key executables for running ABT on a specific problem.

The core of this template is defining all of the dependencies for each problem.
The default dependencies are the other object files in the same folder as
solve.cpp and simulate.cpp, the solver archive libabt.a, and the external
library libspatialindex.

If your problem needs to be linked to additional libraries, you can specify
this by adding those dependencies to the variable
EXTRA_LINKER_ARGS\_[module].
[TOC]

[Tag]: @ref src/problems/tag
[RockSample]: @ref src/problems/rocksample


[Solver]: @ref solver::Solver


[Action]: @ref solver::Action
[Model]: @ref solver::Model
[ModelChange]: @ref solver::ModelChange
[Heuristic]: @ref solver::Heuristic
[Observation]: @ref solver::Observation
[Options]: @ref solver::Options
[State]: @ref solver::State
[TransitionParameters]: @ref solver::TransitionParameters
[Vector]: @ref solver::Vector
[VectorState]: @ref solver::VectorState


[Model::isTerminal]: @ref solver::Model::isTerminal
[Model::sampleAnInitState]: @ref solver::Model::sampleAnInitState
[Model::sampleStateUninformed]: @ref solver::Model::sampleStateUninformed
[Model::applyChanges]: @ref solver::Model::applyChanges
[Model::getHeuristicFunction]: @ref solver::Model::getHeuristicFunction

[Model::generateParticles]: @ref solver::Model::generateParticles
[Model::generateParticles2]: @ref solver::Model::generateParticles(BeliefNode*, Action const &, Observation const &, long)

[Model::generateStep]: @ref solver::Model::generateStep
[Model::generateTransition]: @ref solver::Model::generateTransition
[Model::generateNextState]: @ref solver::Model::generateNextState
[Model::generateObservation]: @ref solver::Model::generateObservation
[Model::generateReward]: @ref solver::Model::generateReward

[Model::createActionPool]: @ref solver::Model::createActionPool
[Model::createStateIndex]: @ref solver::Model::createStateIndex


[Options::discountFactor]: @ref solver::Options::discountFactor
[Options::numberOfStateVariables]: @ref solver::Options::numberOfStateVariables


[copy()]: @ref solver::Point::copy
[equals()]: @ref solver::Point::equals
[hash()]: @ref solver::Point::hash
[distanceTo()]: @ref solver::Point::distanceTo
[print()]: @ref solver::Point::print


[StatePool]: @ref solver::StatePool
[StateIndex]: @ref solver::StateIndex
[RTree]: @ref solver::RTree
[Vector::asVector]: @ref solver::Vector::asVector


[ActionPool]: @ref solver::ActionPool
[ActionMapping]: @ref solver::ActionMapping
[ActionMapping::getNextActionToTry]: @ref solver::ActionMapping::getNextActionToTry
[UCB search strategy]: @ref solver::UcbStepGenerator::getStep

[EnumeratedActionPool]: @ref solver::EnumeratedActionPool
[DiscretizedPoint]: @ref solver::DiscretizedPoint
[DiscretizedPoint::getBinNumber]: @ref solver::DiscretizedPoint::getBinNumber


[HistoryCorrector]: @ref solver::HistoryCorrector
[DefaultHistoryCorrector]: @ref solver::DefaultHistoryCorrector



[Serializer]: @ref solver::Serializer
[TextSerializer]: @ref solver::TextSerializer
[DiscreteObservationPool]: @ref solver::DiscreteObservationPool
[DiscreteObservationTextSerializer]: @ref solver::DiscreteObservationTextSerializer
[EnumeratedActionPool]: @ref solver::EnumeratedActionPool
[EnumeratedActionTextSerializer]: @ref solver::EnumeratedActionTextSerializer
[TagTextSerializer]: @ref tag::TagTextSerializer



[ModelWithProgramOptions]: @ref shared::ModelWithProgramOptions
[SharedOptions]: @ref shared::SharedOptions

[Tag_config]: ../src/problems/tag/tests/default.cfg
[TagOptions]: @ref tag::TagOptions
[TagModel]: @ref tag::TagModel
[TagState]: @ref tag::TagState
[TagAction]: @ref tag::TagAction
[TagObservation]: @ref tag::TagObservation

[TagChange]: @ref tag::TagChange
[TagTextSerializer::saveModelChange]: @ref tag::TagTextSerializer::saveModelChange
[TagTextSerializer::loadModelChange]: @ref tag::TagTextSerializer::loadModelChange
[TagModel::applyChanges]: @ref tag::TagModel::applyChanges



[solve.hpp]: @ref solve.hpp
[simulate.hpp]: @ref simulate.hpp
[Tag_solve.cpp]: @ref src/problems/tag/solve.cpp
[Tag_simulate.cpp]: @ref src/problems/tag/simulate.cpp


[Makefile]: ../Makefile
[Makefile_src]: ../src/Makefile
[Makefile_solver]: ../src/solver/Makefile
[Build README]: @ref build-system
[build.mk]: ../.make/build.mk
[stack.mk]: ../.make/stack.mk
[template.mk]: ../.make/template.mk
[problem-template.mk]: ../.make/problem-template.mk
