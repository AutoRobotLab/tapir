<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ABT: Code structure and examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ABT
   </div>
   <div id="projectbrief">An online approximate POMDP solver that can adapt to changes in the POMDP model.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Code structure and examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The core solver code is located in src/solver, while several example problems are given in src/problems:</p>
<ul>
<li><a href="src/problems/tag">Tag</a></li>
<li><a href="src/problems/rocksample">RockSample</a></li>
</ul>
<h2>Configuration and Building </h2>
<p>This project uses a custom GNU Make build system, which is documented in further detail in .make/README.md "this README"; the dependencies are cleanly generated and make can easily be run in parallel (e.g. make -j8). The code should build OK without any special configuration, but if need be the core build settings ca be changed via the [root Makefile][Makefile].</p>
<p>To build the core solver, simply use the command "make solver" - this will build the solver as a static library in builds/release/libabt.a. Alternatively, the solver can also be built as a shared library - use the command "make solver CFG=shared", and the library file will be output to builds/shared/libabt.so.</p>
<p>The supplied code also comes with several example problems, as mentioned previously. To build the code with all of the example problems, simply use the command "make all" from the root directory. Alternatively, you can build only a specific problem by specifying that problem as a target (e.g. "make tag"), or by running the make command from within that problem's source folder.</p>
<p>Different build configurations are available via the "CFG" variable in the Makefile, which can be set from the command line, e.g. "make CFG=shared", which, as previously mentioned, builds the solver as a shared library rather than via static linking. For debugging output, use "make CFG=debug", or change "DEFAULT_CFG:=debug" in the [root Makefile][Makefile]. Each configuration sends its output into a different directory, which will be "builds/$(CFG)".</p>
<p>For additional documentation on the build system, see the .make/README.md "build system README".</p>
<h2>Usage </h2>
<p>First of all, the solver can be used for your own purposes in library form; simply build it as either a static or dynamic library (as per the <a href="#configuration-and-building">previous section</a>) and then link against it.</p>
<p>If you want to run the example problems, you should first compile those problems, as per the <a href="#configuration-and-building">previous section</a>. Each problem should generate two core executables - "solve" for initial offline policy generation, and "simulate" for online simulation. After building, these executables are placed into the directory bin/basic; in order to use the default configuration settings, the executables must be run from the main project folder.</p>
<p>Each problem will have its own setings, which can be configured in one of two ways - via command line parameters, or via configuration files. Any parameters passed via command line will override the settings in the file. For a quick summary of the command-line parameters available, run the executable with an argument of "--help" for the usage information. More advanced settings are available via config files; default versions of the configuration files are located in the directory "cfg" - for example, see <a href="cfg/tag/default.cfg">cfg/tag/default.cfg</a>. The actual settings that are available in each config file are defined by subclasses of the base <a href="src/solver/abstract-problem/Options.hpp">Options</a> class, e.g. <a href="src/problems/tag/TagOptions.hpp">TagOptions</a> specifies all of the options that can be configured for Tag.</p>
<h2>Implementing a new POMDP model </h2>
<p>At its core, implementation of a specific POMDP problem is done via an implementation of the <a href="src/solver/abstract-problem/Model.hpp">Model</a> interface, which represents a black-box generative model of a POMDP. See <a href="src/problems/tag/TagModel.cpp">TagModel</a> for an example implementation of this interface for the Tag POMDP.</p>
<p>Formally, a POMDP can be specified as an 8-tuple, (S, A, O, T, Z, R, b0, γ), where</p>
<ul>
<li>S is a set of states</li>
<li>A is a set of actions</li>
<li>O is a set of observations</li>
<li>T is the transition function, which is a conditional probability distribution for the next state given the previous state and action, i.e. T(s, a, s') = p(s' | s, a)</li>
<li>Z is the observation function, which is a conditional probability distrubtion for the observation given the action and the resulting state, i.e. Z(a, o, s') = p(o | a, s')</li>
<li>R is the reward function, which returns the expected reward for a given state and action, i.e. R(s, a)</li>
<li>b0 is a probability distribution over states, which represents the agent's initial knowledege.</li>
<li>γ is the discount factor for the POMDP</li>
</ul>
<p>Since this is a black box model, many of these elements are defined implicitly rather than explicitly. The key requirements to specify a POMDP model are:</p>
<ul>
<li><a href="src/solver/abstract-problem/Model.hpp#L109">Model::sampleAnInitState</a> should sample an initial state from the initial belief, and hence implicitly defines b0</li>
<li><a href="src/solver/abstract-problem/Model.hpp#L146">Model::generateStep</a> offers a simple generative model of the POMDP; it takes a single state and action, and returns an observation, next state, and a sampled reward value r, i.e. (s, a) =&gt; (o, r, s'). This forms an implicit definition of the transition, observation and reward functions, T, Z, and R</li>
<li><a href="src/solver/abstract-problem/Options.hpp#L37">Options::discountFactor</a> defines the POMDP discount factor, γ - each <a href="src/solver/abstract-problem/Model.hpp">Model</a> will posses a unique instance of the <a href="src/solver/abstract-problem/Options.hpp">Options</a> class (or a subclass, such as <a href="src/problems/tag/TagOptions.hpp">TagOptions</a>).</li>
<li><a href="src/solver/abstract-problem/Model.hpp#L115">Model::isTerminal</a> specifies which states will be considered terminal - the method should return true for those states, and false for others.</li>
</ul>
<p>As for S, A, and O, the states, actions, and observations should implement their respective abstract classes <a href="src/solver/abstract-problem/State.hpp">State</a>, <a href="src/solver/abstract-problem/Action.hpp">Action</a>, and <a href="src/solver/abstract-problem/Observation.hpp">Observation</a>. That said, it is important to note that the sets of states and observations are actually implicitly defined via the black-box sampling methods - <a href="src/solver/abstract-problem/Model.hpp#L109">Model::sampleAnInitState</a> should return a state within S, and <a href="src/solver/abstract-problem/Model.hpp#L146">Model::generateStep</a> should return states and observations that are within S and O respectively. However, since the solver itself needs to select actions, actions require more explicit treatment by the ABT algorithm. This is done via the <a href="src/solver/mappings/actions/ActionPool.hpp">ActionPool</a> interface and the method <a href="src/solver/abstract-problem/Model.hpp#L309">Model::createActionPool</a>; see the <a href="#actionpool">section below</a> for some additional details.</p>
<p>See below for a more detailed description of the core functionality needed in order to make a new problem for the ABT code.</p>
<h3>Model</h3>
<p>As previously mentioned, the <a href="src/solver/abstract-problem/Model.hpp">Model</a> class is the core interface for the specification of a POMDP model; see <a href="src/problems/tag/TagModel.cpp">TagModel</a> for a concrete example. An implementation of <a href="src/solver/abstract-problem/Model.hpp">Model</a> must, at the very least, implement all of the pure virtual methods in the abstract base class. These include the aforementioned core methods <a href="src/solver/abstract-problem/Model.hpp#L109">Model::sampleAnInitState</a>, <a href="src/solver/abstract-problem/Model.hpp#L146">Model::generateStep</a>, and <a href="src/solver/abstract-problem/Model.hpp#L115">Model::isTerminal</a>, as specified previously. A <a href="src/solver/abstract-problem/Model.hpp">Model</a> instance will also possess an <a href="src/solver/abstract-problem/Options.hpp">Options</a> instance, which specifies various ABT and POMDP parameters.</p>
<p>In addition to the these three core methods, and <a href="src/solver/abstract-problem/Model.hpp#L309">Model::createActionPool</a> (see <a href="#actionpool">this section</a> for further details), a Model must also implement <a href="src/solver/abstract-problem/Model.hpp#L113">Model::sampleStateUninformed</a>, which should generate states according to an uninformed prior (as opposed to from the initial belief); this is used by the default implementation for the <a href="src/solver/abstract-problem/Model.hpp#L232">uninformed generateParticles</a> method. Custom implementations for the two particle filtering methods ( <a href="src/solver/abstract-problem/Model.hpp#L219">informed</a> and <a href="src/solver/abstract-problem/Model.hpp#L232">uninformed</a> ) can be written if better handling of particle depletion is needed. Also of key importance (although not mandatory) is a heuristic function, which is specified by <a href="src/solver/abstract-problem/Model.hpp#L257">Model::getHeuristicFunction</a> - this uses a functional programming interface, and should return a <a href="src/solver/abstract-problem/HeuristicFunction.hpp">HeuristicFunction</a>. By default, the heuristic function is simply one that always returns zero.</p>
<p>If you wish the model to handle changes, see <a href="#implementing-changes">the section on changes</a> below; in short, doing so requires implementations for several other methods, most notably <a href="src/solver/abstract-problem/Model.hpp#L208">Model::applyChanges</a>.</p>
<p>A convenient subclass of <a href="src/solver/abstract-problem/Model.hpp">Model</a> is <a href="src/problems/shared/ModelWithProgramOptions.hpp">ModelWithProgramOptions</a>, which uses additional options from <a href="src/problems/shared/SharedOptions.hpp">SharedOptions</a> to provide some extra configuration settings, including text-based parsing in order to select different search strategies.</p>
<h3>Options</h3>
<p>Each <a href="src/solver/abstract-problem/Model.hpp">Model</a> instance should possess an <a href="src/solver/abstract-problem/Options.hpp">Options</a> instance, which specifies the various configuration settings to use for that problem, and for ABT to use when solving that problem. The base <a href="src/solver/abstract-problem/Options.hpp">Options</a> class has several parameters for ABT settings, but with respect to specifying a POMDP there are two crucial values that must be specified:</p>
<ul>
<li><a href="src/solver/abstract-problem/Options.hpp#L37">Options::discountFactor</a> - the POMDP discount factor.</li>
<li><a href="src/solver/abstract-problem/Options.hpp#L29">Options::numberOfStateVariables</a> - the number of state variables used to define a state of the POMDP.</li>
</ul>
<h3>State</h3>
<p>Represents a state within the state space of the problem. See <a href="src/problems/tag/TagState.cpp">TagState</a> for an example.</p>
<p>The core implementation requires only the following methods:</p>
<ul>
<li><a href="src/solver/abstract-problem/Point.hpp#L40">copy()</a> &mdash; duplicates the state</li>
<li><a href="src/solver/abstract-problem/Point.hpp#L46">hash()</a> &mdash; hashes the state for storage in an std::unordered_map</li>
<li><a href="src/solver/abstract-problem/Point.hpp#L43">equals()</a> &mdash; identifies equivalent states; used in conjunction with <a href="src/solver/abstract-problem/Point.hpp#L46">hash()</a></li>
</ul>
<p>Also useful (though not required) are:</p>
<ul>
<li><a href="src/solver/abstract-problem/Point.hpp#L49">distanceTo()</a> &mdash; defines a distance metric over the states; the default is an infinite distance between any pair of states.</li>
<li><a href="src/solver/abstract-problem/Point.hpp#L54">print()</a> &mdash; generates a human-readable text representation of the state.</li>
</ul>
<p>In order to be able to make changes to the policy when changes to the model occur, states also need to be stored within a <a href="src/solver/indexing/StateIndex.hpp">StateIndex</a>. The default implementation for this is an R*-tree, which is implemented via a <a href="src/solver/indexing/RTree.hpp">thin wrapper</a> around the <a href="http://libspatialindex.github.io/overview.html#the-rtree-package">R*-tree implementation</a> from <a href="http://libspatialindex.github.io">libspatialindex</a>. In order to use this implementation, the <a href="src/solver/abstract-problem/State.hpp">State</a> needs to implement <a href="src/solver/abstract-problem/VectorState.hpp">VectorState</a>. In addition to the standard <a href="src/solver/abstract-problem/State.hpp">State</a> methods, this also requires the additional method <a href="src/solver/abstract-problem/Vector.hpp#L39">asVector()</a>, which must return an std::vector&lt;double&gt; representation of the state; this vector will then be stored inside the <a href="src/solver/indexing/RTree.hpp">R*-tree</a>.</p>
<p>Alternatively, a custom <a href="src/solver/indexing/StateIndex.hpp">StateIndex</a> implementation can be given by implementing <a href="src/solver/indexing/StateIndex.hpp">StateIndex</a> and having <a href="src/solver/abstract-problem/Model.hpp#L289">Model::createStateIndex</a> return an instance of that custom implementation.</p>
<h3>Observation</h3>
<p>Represents an observation within the action space of the problem. See <a href="src/problems/tag/TagObservation.cpp">TagObservation</a> for an example. Like <a href="src/solver/abstract-problem/State.hpp">State</a>, the <a href="src/solver/abstract-problem/Observation.hpp">Observation</a> interface requires implementations for <a href="src/solver/abstract-problem/Point.hpp#L40">copy()</a>, <a href="src/solver/abstract-problem/Point.hpp#L43">equals()</a>, and <a href="src/solver/abstract-problem/Point.hpp#L46">hash()</a>, and custom implementations can be given for <a href="src/solver/abstract-problem/Point.hpp#L49">distanceTo()</a> and <a href="src/solver/abstract-problem/Point.hpp#L54">print()</a></p>
<h3>Action</h3>
<p>Represents an action within the action space of the problem. See <a href="src/problems/tag/TagAction.cpp">TagAction</a> for an example. Like <a href="src/solver/abstract-problem/State.hpp">State</a>, the <a href="src/solver/abstract-problem/Action.hpp">Action</a> interface requires implementations for <a href="src/solver/abstract-problem/Point.hpp#L40">copy()</a>, <a href="src/solver/abstract-problem/Point.hpp#L43">equals()</a>, and <a href="src/solver/abstract-problem/Point.hpp#L46">hash()</a>, and custom implementations can be given for <a href="src/solver/abstract-problem/Point.hpp#L49">distanceTo()</a> and <a href="src/solver/abstract-problem/Point.hpp#L54">print()</a></p>
<h3>ActionPool</h3>
<p>In order for the ABT solver to be able to search the space of possible actions, it needs a way to know which actions it will need to try, and at which belief nodes. This is handled in a generic manner by the <a href="src/solver/mappings/actions/ActionPool.hpp">ActionPool</a> interface - the <a href="src/solver/mappings/actions/ActionPool.hpp">ActionPool</a> essentially works as a factory to generate individual instances of <a href="src/solver/mappings/actions/ActionMapping.hpp">ActionMapping</a> for each belief node. When ABT is searching using the standard <a href="src/solver/search/steppers/ucb_search.cpp#L27">UCB search strategy</a>, it queries the <a href="src/solver/mappings/actions/ActionMapping.hpp">ActionMapping</a> using <a href="src/solver/mappings/actions/ActionMapping.hpp#L84">ActionMapping::getNextActionToTry</a>; this essentially defines the initialization phase of he UCB algorithm - as long as this method returns actions (rather than nullptr), these actions will continue to be tried; moreover, it is only those actions that have been tried before that will actually be selected once the actual UCB algorithm is being used.</p>
<p>A standard implementation of <a href="src/solver/mappings/actions/ActionPool.hpp">ActionPool</a> that should be sufficient for most purposes is provided as <a href="src/solver/mappings/actions/enumerated_actions.hpp#L37">EnumeratedActionPool</a>. This implementation assumes that there is a finite, and relatively small, enumerated set of global actions that can be taken from any state in the problem. Use of this implementation has two prerequsites:</p>
<ul>
<li>The <a href="src/solver/abstract-problem/Action.hpp">Action</a> class used must implement the <a href="src/solver/abstract-problem/DiscretizedPoint.hpp">DiscretizedPoint</a> interface, which requires that every action be able to return its associated index in the enumeration via the method <a href="src/solver/abstract-problem/DiscretizedPoint.hpp#L38">DiscretizedPoint::getBinNumber</a></li>
<li>The <a href="src/solver/mappings/actions/enumerated_actions.hpp#L37">EnumeratedActionPool</a> constructor requires, as a constructor argument, a vector containing all of the actions, in the order of their enumeration.</li>
</ul>
<h3>Serializer</h3>
<p>If you require the ability to serialize a solver policy (e.g. to save it to a file), you must provide an implementation of the abstract <a href="src/solver/serialization/Serializer.hpp">Serializer</a> class. A basic implementation that generates human-readable text representations of all of the core ABT solver classes is provided by <a href="src/solver/serialization/TextSerializer.hpp">TextSerializer</a>, but this implementation is only partial, because it doesn't come with implementations for the various configurable data structures. As such, in order to fully implement a <a href="src/solver/serialization/Serializer.hpp">Serializer</a> for your problem, you will also need to implement methods to serialize a few of the core interface classes - that is, <a href="src/solver/abstract-problem/State.hpp">State</a>, <a href="src/solver/abstract-problem/Action.hpp">Action</a>, and <a href="src/solver/abstract-problem/Observation.hpp">Observation</a>. Additionally, the action and observation mappings also need serialization. The default observation mapping is <a href="src/solver/mappings/observations/discrete_observations.hpp#L36">DiscreteObservationPool</a>, which should suffice for most purposes; in order to serialize this mapping class, the serializer implementation should also inherit from <a href="src/solver/mappings/observations/discrete_observations.hpp#L36">DiscreteObservationTextSerializer</a>. Similarly, if you use <a href="src/solver/mappings/actions/enumerated_actions.hpp#L37">EnumeratedActionPool</a> for mapping actions, your serializer should inherit from <a href="src/solver/mappings/actions/enumerated_actions.hpp#L68">EnumeratedActionTextSerializer</a>.</p>
<p>To see a good example of the above, have a look at <a href="src/problems/tag/TagTextSerializer.hpp">TagTextSerializer</a>.</p>
<h2>Implementing changes </h2>
<p>It is not mandatory for a <a href="src/solver/abstract-problem/Model.hpp">Model</a> implementation to deal with changes, but if you require this functionality, the following two core implementation details are the most important:</p>
<ul>
<li>A custom <a href="src/solver/abstract-problem/ModelChange.hpp">ModelChange</a> class, e.g. <a href="src/problems/tag/TagModel.hpp#L37">TagChange</a>. This class doesn't have any required methods, because it's up to each individual <a href="src/solver/abstract-problem/Model.hpp">Model</a> implementation to determine how it deals with changes. Note that if you implement <a href="src/solver/abstract-problem/ModelChange.hpp">ModelChange</a> you will likely also need to implement serialization methods, e.g. <a href="src/problems/tag/TagTextSerializer.cpp#L40">TagTextSerializer::saveModelChange</a> and <a href="src/problems/tag/TagTextSerializer.cpp#L61">TagTextSerializer::loadModelChange</a></li>
<li>An implementation of <a href="src/solver/abstract-problem/Model.hpp#L208">Model::applyChanges</a>, which performs two key functions:<ul>
<li>Updating the Model's black box generators in response to the changes.</li>
<li>Informing the Solver of the changes that have been applied. This is done via the <a href="src/solver/StatePool.hpp">StatePool</a> interface, which can be used in conjunction with a custom <a href="src/solver/indexing/StateIndex.hpp">StateIndex</a> implementation, e.g. <a href="src/solver/indexing/RTree.hpp">RTree</a>, in order to perform more intelligent queries. See <a href="src/problems/tag/TagModel.cpp#L323">TagModel::applyChanges</a> for an example implentation.</li>
</ul>
</li>
</ul>
<p>The <a href="src/solver/Solver.hpp">Solver</a> handles model changes by using a <a href="src/solver/changes/HistoryCorrector.hpp">HistoryCorrector</a>, the default implementation of which is <a href="src/solver/changes/DefaultHistoryCorrector.hpp">DefaultHistoryCorrector</a>, which should work OK for any custom problem. However, in order to use this implementation you must also implement these methods of <a href="src/solver/abstract-problem/Model.hpp">Model</a>:</p>
<ul>
<li><a href="src/solver/abstract-problem/Model.hpp#L165">Model::generateNextState</a> to generate states - an implicit definition of T(s, a, s')</li>
<li><a href="src/solver/abstract-problem/Model.hpp#L176">Model::generateObservation</a> to generate observations - an implicit definition of Z(a, o, s')</li>
<li><a href="src/solver/abstract-problem/Model.hpp#L189">Model::generateReward</a> to generate rewards - an implicit definition of R(s, a)</li>
</ul>
<p>These three methods are used instead of <a href="src/solver/abstract-problem/Model.hpp#L146">Model::generateStep</a> in order to avoid unnecessary recalculation, and to minize the extent to which new histories diverge from old ones due to re-randomization. To minimize such issues even further, you can use <a href="src/solver/abstract-problem/TransitionParameters.hpp">TransitionParameters</a> and <a href="src/solver/abstract-problem/Model.hpp#L155">Model::generateTransition</a>, which allows you to store extra information about a generated step. This can be used, for example, to store intermediate calculations, or generated random numbers. See the documentation of <a href="src/solver/abstract-problem/Model.hpp">Model</a> for greater detail.</p>
<h2>Generating binaries for a new POMDP model </h2>
<p>For additional convenience, template methods to generate binaries for an individual problem are given in:</p>
<ul>
<li><a href="src/problems/shared/solve.hpp">solve.hpp</a> &mdash; initial offline policy generation; see <a href="src/problems/tag/solve.cpp">solve.cpp for Tag</a> for a usage example.</li>
<li><a href="src/problems/shared/simulate.hpp">simulate.hpp</a> &mdash; simulation with online POMDP solution; see <a href="src/problems/tag/simulate.cpp">simulate.cpp for Tag</a> for a usage example. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2014 21:54:10 for ABT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
