<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TAPIR: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TAPIR
   </div>
   <div id="projectbrief">An online approximate POMDP solver that can adapt to changes in the POMDP model.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TAPIR Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tapir">Toolkit for approximating and Adapting POMDP solutions In Realtime (TAPIR) </a><ul><li class="level2"><a href="#system-requirements">System Requirements </a></li>
<li class="level2"><a href="#example-problems">Example problems </a></li>
<li class="level2"><a href="#configuration-and-building">Configuration and Building </a></li>
<li class="level2"><a href="#usage">Usage </a></li>
<li class="level2"><a href="#implementing-a-new-pomdp-model">Implementing a new POMDP model </a><ul><li class="level3"><a href="#model">Model</a></li>
<li class="level3"><a href="#options">Options</a></li>
<li class="level3"><a href="#state">State</a></li>
<li class="level3"><a href="#observation">Observation</a></li>
<li class="level3"><a href="#action">Action</a></li>
<li class="level3"><a href="#actionpool">ActionPool</a></li>
<li class="level3"><a href="#serializer">Serializer</a></li>
</ul>
</li>
<li class="level2"><a href="#implementing-changes">Implementing changes </a></li>
<li class="level2"><a href="#generating-binaries-for-a-new-pomdp-model">Generating binaries for a new POMDP model </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tapir"></a>
Toolkit for approximating and Adapting POMDP solutions In Realtime (TAPIR) </h1>
<p>TAPIR is a C++ implementation of the Adaptive Belief Tree (ABT) algorithm [1]. ABT is an online POMDP solver capable of adapting to modifications to the POMDP model without the need to reconstruct the policy from scratch.</p>
<p>[1] H. Kurniawati and V. Yadav. An Online POMDP Solver for Uncertainty Planning in Dynamic Environment. Proc. Int. Symp. on Robotics Research. 2013. <a href="http://robotics.itee.uq.edu.au/~hannakur/dokuwiki/papers/isrr13_abt.pdf">http://robotics.itee.uq.edu.au/~hannakur/dokuwiki/papers/isrr13_abt.pdf</a></p>
<p>For bug reports and suggestions, please email <a href="#" onclick="location.href='mai'+'lto:'+'rdl'+'.a'+'lgo'+'ri'+'thm'+'@i'+'tee'+'.u'+'q.e'+'du'+'.au'; return false;">rdl.a<span style="display: none;">.nosp@m.</span>lgor<span style="display: none;">.nosp@m.</span>ithm@<span style="display: none;">.nosp@m.</span>itee<span style="display: none;">.nosp@m.</span>.uq.e<span style="display: none;">.nosp@m.</span>du.a<span style="display: none;">.nosp@m.</span>u</a></p>
<p>For information on updates, please visit <a href="http://robotics.itee.uq.edu.au/~tapir">http://robotics.itee.uq.edu.au/~tapir</a></p>
<h2><a class="anchor" id="system-requirements"></a>
System Requirements </h2>
<p>Operating systems:</p>
<ul>
<li>Linux</li>
<li>Windows (untested)</li>
</ul>
<p>Building and running the C++ source code requires:</p>
<ul>
<li><a href="https://gcc.gnu.org">GNU C++ compiler</a> (&gt;= 4.8) or equivalent</li>
<li><a href="http://libspatialindex.github.io">libspatialindex</a> (&gt;= 1.7.0) Debian/Ubuntu package name: "libspatialindex-dev"</li>
<li><a href="http://eigen.tuxfamily.org">Eigen 3</a> (&gt;= 3.2.0) Debian/Ubuntu package name: "libeigen3-dev"</li>
</ul>
<h2><a class="anchor" id="example-problems"></a>
Example problems </h2>
<p>The core solver code is located in <a class="el" href="dir_041db6ad6a3d44280e40e5af409429cb.html">src/solver</a>, while several example problems are given in [src/problems]:</p>
<ul>
<li>Tag (<a class="el" href="dir_7fd0f5f213bcbde0c602c6d58d54ed57.html">src/problems/tag</a>) - see <a href="http://www.cs.cmu.edu/~ggordon/jpineau-ggordon-thrun.ijcai03.pdf">here</a> for a problem description.</li>
<li>RockSample (<a class="el" href="dir_5c43e7e6616020857693cbaff300da49.html">src/problems/rocksample</a>) - see <a href="http://arxiv.org/ftp/arxiv/papers/1207/1207.4166.pdf">here</a> for a problem description.</li>
</ul>
<h2><a class="anchor" id="configuration-and-building"></a>
Configuration and Building </h2>
<p>This project uses a custom GNU Make build system, which is documented in further detail in <a class="el" href="md_docs_generated_Build_System.html">this README</a>; the dependencies are cleanly managed and make can easily be run in parallel, i.e. </p>
<pre class="fragment">make -jN
</pre><p>where N is the number of threads you want to use; 8 is good for many CPUs. The code should build OK without any special configuration, but if need be the core build settings can be changed via the <a href="../Makefile">root Makefile</a>.</p>
<p>To build the core solver, simply use the command </p>
<pre class="fragment">make solver
</pre><p>This will build the solver as a static library in builds/release/libtapir.a. Alternatively, the solver can also be built as a shared library - use the command </p>
<pre class="fragment">make solver CFG=shared
</pre><p>and a shared library file will be output to builds/shared/libtapir.so</p>
<p>The supplied code also comes with several example problems, as mentioned previously. To build the code with all of the example problems, simply use the command </p>
<pre class="fragment">make all
</pre><p>Alternatively, you can build only a specific problem by specifying that problem as a target. For example, </p>
<pre class="fragment">make tag -j4 CFG=shared
</pre><p>would use 4 threads to compile; that command would build the solver as a shared library, and also build the Tag problem to dynamically link against the shared library file. Alternatively, you can also compile a problem by running make from within that problem's source folder, e.g. </p>
<pre class="fragment">cd src/problems/tag
make
</pre><p>Different build configurations are available via the "CFG" variable in the Makefile, which can be set from the command line; for example, debugging output can be generated by using </p>
<pre class="fragment">make CFG=debug
</pre><p>or by setting </p>
<pre class="fragment">DEFAULT_CFG:=debug
</pre><p>in the <a href="../Makefile">root Makefile</a>. Each configuration sends its output into a different directory, which will be "builds/$(CFG)".</p>
<p>For additional documentation on the build system, see the <a class="el" href="md_docs_generated_Build_System.html">build system README</a>.</p>
<h2><a class="anchor" id="usage"></a>
Usage </h2>
<p>First of all, the solver can be used for your own purposes in library form; simply build it as either a static or dynamic library (as per the <a href="#configuration-and-building">previous section</a>) and then link against it.</p>
<p>If you want to run the example problems, you should first compile those problems, as per the <a href="#configuration-and-building">previous section</a>. Each problem should generate two core executables - "solve" for initial offline policy generation, and "simulate" for online simulation. After building, these executables are placed into the directory bin/basic; in order to use the default configuration settings, the executables must be run from the main project folder.</p>
<p>Each problem will have its own setings, which can be configured in one of two ways - via command line parameters, or via configuration files. Any parameters passed via command line will override the settings in the file. For a quick summary of the command-line parameters available, run the executable with an argument of "--help" for the usage information. More advanced settings are available via config files; default versions of the configuration files are located in the directory "cfg" - for example, see <a class="el" href="tag_2default_8cfg_source.html">cfg/tag/default.cfg</a>. The actual settings that are available in each config file are defined by subclasses of the base <a class="el" href="structsolver_1_1Options.html">Options</a> class, e.g. <a class="el" href="structtag_1_1TagOptions.html">TagOptions</a> specifies all of the options that can be configured for Tag.</p>
<h2><a class="anchor" id="implementing-a-new-pomdp-model"></a>
Implementing a new POMDP model </h2>
<p>At its core, implementation of a specific POMDP problem is done via an implementation of the <a class="el" href="classsolver_1_1Model.html">Model</a> interface, which represents a black-box generative model of a POMDP. See <a class="el" href="classtag_1_1TagModel.html">TagModel</a> for an example implementation of this interface for the Tag POMDP.</p>
<p>Formally, a POMDP can be specified as an 8-tuple, (S, A, O, T, Z, R, b0, γ), where</p>
<ul>
<li>S is a set of states</li>
<li>A is a set of actions</li>
<li>O is a set of observations</li>
<li>T is the transition function, which is a conditional probability distribution for the next state given the previous state and action, i.e. T(s, a, s') = p(s' | s, a)</li>
<li>Z is the observation function, which is a conditional probability distrubtion for the observation given the action and the resulting state, i.e. Z(a, o, s') = p(o | a, s')</li>
<li>R is the reward function, which returns the expected reward for a given state and action, i.e. R(s, a)</li>
<li>b0 is a probability distribution over states, which represents the agent's initial knowledege.</li>
<li>γ is the discount factor for the POMDP</li>
</ul>
<p>Since this is a black box model, many of these elements are defined implicitly rather than explicitly. The key requirements to specify a POMDP model are:</p>
<ul>
<li><a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c">Model::sampleAnInitState</a> should sample an initial state from the initial belief, and hence implicitly defines b0</li>
<li><a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">Model::generateStep</a> offers a simple generative model of the POMDP; it takes a single state and action, and returns an observation, next state, and a sampled reward value r, i.e. (s, a) =&gt; (o, r, s'). This forms an implicit definition of the transition, observation and reward functions, T, Z, and R</li>
<li><a class="el" href="structsolver_1_1Options.html#a3c9e50bb47ebb7ccb8b715544432e875">Options::discountFactor</a> defines the POMDP discount factor, γ - each <a class="el" href="classsolver_1_1Model.html">Model</a> will posses a unique instance of the <a class="el" href="structsolver_1_1Options.html">Options</a> class (or a subclass, such as <a class="el" href="structtag_1_1TagOptions.html">TagOptions</a>).</li>
<li><a class="el" href="classsolver_1_1Model.html#afaefbb5cafd6984d16d0e7972e96befd">Model::isTerminal</a> specifies which states will be considered terminal - the method should return true for those states, and false for others.</li>
</ul>
<p>As for S, A, and O, the states, actions, and observations should implement their respective abstract classes <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a>, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a>, and <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a>. That said, it is important to note that the sets of states and observations are actually implicitly defined via the black-box sampling methods - <a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c">Model::sampleAnInitState</a> should return a state within S, and <a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">Model::generateStep</a> should return states and observations that are within S and O respectively. However, since the solver itself needs to select actions, actions require more explicit treatment by the ABT algorithm. This is done via the <a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a> interface and the method <a class="el" href="classsolver_1_1Model.html#a153e447124946743272c156ee40e7024">Model::createActionPool</a>; see the <a href="#actionpool">section below</a> for some additional details.</p>
<p>See below for a more detailed description of the core functionality needed in order to make a new problem for TAPIR.</p>
<h3><a class="anchor" id="model"></a>
Model</h3>
<p>As previously mentioned, the <a class="el" href="classsolver_1_1Model.html">Model</a> class is the core interface for the specification of a POMDP model; see <a class="el" href="classtag_1_1TagModel.html">TagModel</a> for a concrete example. An implementation of <a class="el" href="classsolver_1_1Model.html">Model</a> must, at the very least, implement all of the pure virtual methods in the abstract base class. These include the aforementioned core methods <a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c">Model::sampleAnInitState</a>, <a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">Model::generateStep</a>, and <a class="el" href="classsolver_1_1Model.html#afaefbb5cafd6984d16d0e7972e96befd">Model::isTerminal</a>, as specified previously. A <a class="el" href="classsolver_1_1Model.html">Model</a> instance will also possess an <a class="el" href="structsolver_1_1Options.html">Options</a> instance, which specifies various ABT and POMDP parameters.</p>
<p>In addition to the these three core methods, and <a class="el" href="classsolver_1_1Model.html#a153e447124946743272c156ee40e7024">Model::createActionPool</a> (see <a href="#actionpool">this section</a> for further details), a Model must also implement <a class="el" href="classsolver_1_1Model.html#a7c3fd2691ae717aa5cdf61fe32269f5c">Model::sampleStateUninformed</a>, which should generate states according to an uninformed prior (as opposed to from the initial belief); this is used by the default implementation for the <a class="el" href="classsolver_1_1Model.html#a0dc0aa58463c5da7385824e08a242dc5">uninformed generateParticles</a> method. Custom implementations for the two particle filtering methods ( <a class="el" href="classsolver_1_1Model.html#a40bf7b0167216caaa37dbc5e79273a8b">informed</a> and <a class="el" href="classsolver_1_1Model.html#a0dc0aa58463c5da7385824e08a242dc5">uninformed</a> ) can be written if better handling of particle depletion is needed. Also of key importance (although not mandatory) is a heuristic function, which is specified by <a class="el" href="classsolver_1_1Model.html#a09a73bc8bd8d983464d6717218f60ba1">Model::getHeuristicFunction</a> - this uses a functional programming interface, and should return a <a class="el" href="namespacesolver.html#a2652743b2b118d001615cc27ed0ce636">HeuristicFunction</a>. By default, the heuristic function is simply one that always returns zero.</p>
<p>If you wish the model to handle changes, see <a href="#implementing-changes">the section on changes</a> below; in short, doing so requires implementations for several other methods, most notably <a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818">Model::applyChanges</a>.</p>
<p>A convenient subclass of <a class="el" href="classsolver_1_1Model.html">Model</a> is <a class="el" href="classshared_1_1ModelWithProgramOptions.html">ModelWithProgramOptions</a>, which uses additional options from <a class="el" href="structshared_1_1SharedOptions.html">SharedOptions</a> to provide some extra configuration settings, including text-based parsing in order to select different search strategies.</p>
<h3><a class="anchor" id="options"></a>
Options</h3>
<p>Each <a class="el" href="classsolver_1_1Model.html">Model</a> instance should possess an <a class="el" href="structsolver_1_1Options.html">Options</a> instance, which specifies the various configuration settings to use for that problem, and for TAPIR to use when solving that problem. The base <a class="el" href="structsolver_1_1Options.html">Options</a> class has several parameters for ABT settings, but with respect to specifying a POMDP there are two crucial values that must be specified:</p>
<ul>
<li><a class="el" href="structsolver_1_1Options.html#a3c9e50bb47ebb7ccb8b715544432e875">Options::discountFactor</a> - the POMDP discount factor.</li>
<li><a class="el" href="structsolver_1_1Options.html#a03872680ab1ff2b338c94a82cb2850f0">Options::numberOfStateVariables</a> - the number of state variables used to define a state of the POMDP.</li>
</ul>
<h3><a class="anchor" id="state"></a>
State</h3>
<p>Represents a state within the state space of the problem. See <a class="el" href="classtag_1_1TagState.html">TagState</a> for an example.</p>
<p>The core implementation requires only the following methods:</p>
<ul>
<li><a class="el" href="classsolver_1_1Point.html#a1d14e193b8a2401b2687b6235ec7d476">copy()</a> &mdash; duplicates the state</li>
<li><a class="el" href="classsolver_1_1Point.html#aa44e8c9c79e70c98a3a6ce58801b7984">hash()</a> &mdash; hashes the state for storage in an std::unordered_map</li>
<li><a class="el" href="classsolver_1_1Point.html#a2e9f83b0a727213df18d57093b0afcc6">equals()</a> &mdash; identifies equivalent states; used in conjunction with <a class="el" href="classsolver_1_1Point.html#aa44e8c9c79e70c98a3a6ce58801b7984">hash()</a></li>
</ul>
<p>Also useful (though not required) are:</p>
<ul>
<li><a class="el" href="classsolver_1_1Point.html#ae0fc60b29ff9ccffdaf483d7fe0b012d">distanceTo()</a> &mdash; defines a distance metric over the states; the default is an infinite distance between any pair of states.</li>
<li><a class="el" href="classsolver_1_1Point.html#ac91e590198c9b870453c0f6959d5b92d">print()</a> &mdash; generates a human-readable text representation of the state.</li>
</ul>
<p>In order to be able to make changes to the policy when changes to the model occur, states also need to be stored within a <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a>. The default implementation for this is an R*-tree, which is implemented via a <a class="el" href="classsolver_1_1RTree.html">thin wrapper</a> around the <a href="http://libspatialindex.github.io/overview.html#the-rtree-package">R*-tree implementation</a> from <a href="http://libspatialindex.github.io">libspatialindex</a>. In order to use this implementation, the <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> needs to implement <a class="el" href="namespacesolver.html#a221357f38a1ef1eaefd1232214b283c5">VectorState</a>. In addition to the standard <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> methods, this also requires the additional method <a class="el" href="classsolver_1_1Vector.html#a66a51dedfc2032726c9eb37c0bdbd0a0">asVector()</a>, which must return an std::vector&lt;double&gt; representation of the state; this vector will then be stored inside the <a class="el" href="classsolver_1_1RTree.html">R*-tree</a>.</p>
<p>Alternatively, a custom <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> implementation can be given by implementing <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> and having <a class="el" href="classsolver_1_1Model.html#aa9099de4b2b73a8b55a916a5ba827401">Model::createStateIndex</a> return an instance of that custom implementation.</p>
<h3><a class="anchor" id="observation"></a>
Observation</h3>
<p>Represents an observation within the action space of the problem. See <a class="el" href="classtag_1_1TagObservation.html">TagObservation</a> for an example. Like <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a>, the <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> interface requires implementations for <a class="el" href="classsolver_1_1Point.html#a1d14e193b8a2401b2687b6235ec7d476">copy()</a>, <a class="el" href="classsolver_1_1Point.html#a2e9f83b0a727213df18d57093b0afcc6">equals()</a>, and <a class="el" href="classsolver_1_1Point.html#aa44e8c9c79e70c98a3a6ce58801b7984">hash()</a>, and custom implementations can be given for <a class="el" href="classsolver_1_1Point.html#ae0fc60b29ff9ccffdaf483d7fe0b012d">distanceTo()</a> and <a class="el" href="classsolver_1_1Point.html#ac91e590198c9b870453c0f6959d5b92d">print()</a></p>
<h3><a class="anchor" id="action"></a>
Action</h3>
<p>Represents an action within the action space of the problem. See <a class="el" href="classtag_1_1TagAction.html">TagAction</a> for an example. Like <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a>, the <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> interface requires implementations for <a class="el" href="classsolver_1_1Point.html#a1d14e193b8a2401b2687b6235ec7d476">copy()</a>, <a class="el" href="classsolver_1_1Point.html#a2e9f83b0a727213df18d57093b0afcc6">equals()</a>, and <a class="el" href="classsolver_1_1Point.html#aa44e8c9c79e70c98a3a6ce58801b7984">hash()</a>, and custom implementations can be given for <a class="el" href="classsolver_1_1Point.html#ae0fc60b29ff9ccffdaf483d7fe0b012d">distanceTo()</a> and <a class="el" href="classsolver_1_1Point.html#ac91e590198c9b870453c0f6959d5b92d">print()</a></p>
<h3><a class="anchor" id="actionpool"></a>
ActionPool</h3>
<p>In order for the ABT solver to be able to search the space of possible actions, it needs a way to know which actions it will need to try, and at which belief nodes. This is handled in a generic manner by the <a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a> interface - the <a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a> essentially works as a factory to generate individual instances of <a class="el" href="classsolver_1_1ActionMapping.html">ActionMapping</a> for each belief node. When ABT is searching using the standard <a class="el" href="classsolver_1_1UcbStepGenerator.html#a18f4dd0ac38aa3684e293342471992d7">UCB search strategy</a>, it queries the <a class="el" href="classsolver_1_1ActionMapping.html">ActionMapping</a> using <a class="el" href="classsolver_1_1ActionMapping.html#aae4246fd955d59ec925b839867a8463d">ActionMapping::getNextActionToTry</a>; this essentially defines the initialization phase of he UCB algorithm - as long as this method returns actions (rather than nullptr), these actions will continue to be tried; moreover, it is only those actions that have been tried before that will actually be selected once the actual UCB algorithm is being used.</p>
<p>A standard implementation of <a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a> that should be sufficient for most purposes is provided as <a class="el" href="classsolver_1_1EnumeratedActionPool.html">EnumeratedActionPool</a>. This implementation assumes that there is a finite, and relatively small, enumerated set of global actions that can be taken from any state in the problem. Use of this implementation has two prerequsites:</p>
<ul>
<li>The <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> class used must implement the <a class="el" href="classsolver_1_1DiscretizedPoint.html">DiscretizedPoint</a> interface, which requires that every action be able to return its associated index in the enumeration via the method <a class="el" href="classsolver_1_1DiscretizedPoint.html#a1e86841df87b1f575a00ed728dfd3de3">DiscretizedPoint::getBinNumber</a></li>
<li>The <a class="el" href="classsolver_1_1EnumeratedActionPool.html">EnumeratedActionPool</a> constructor requires, as a constructor argument, a vector containing all of the actions, in the order of their enumeration.</li>
</ul>
<h3><a class="anchor" id="serializer"></a>
Serializer</h3>
<p>If you require the ability to serialize a solver policy (e.g. to save it to a file), you must provide an implementation of the abstract <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> class. A basic implementation that generates human-readable text representations of all of the core ABT solver classes is provided by <a class="el" href="classsolver_1_1TextSerializer.html">TextSerializer</a>, but this implementation is only partial, because it doesn't come with implementations for the various configurable data structures. As such, in order to fully implement a <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> for your problem, you will also need to implement methods to serialize a few of the core interface classes - that is, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a>, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a>, and <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a>. Additionally, the action and observation mappings also need serialization. The default observation mapping is <a class="el" href="classsolver_1_1DiscreteObservationPool.html">DiscreteObservationPool</a>, which should suffice for most purposes; in order to serialize this mapping class, the serializer implementation should also inherit from <a class="el" href="classsolver_1_1DiscreteObservationTextSerializer.html">DiscreteObservationTextSerializer</a>. Similarly, if you use <a class="el" href="classsolver_1_1EnumeratedActionPool.html">EnumeratedActionPool</a> for mapping actions, your serializer should inherit from <a class="el" href="namespacesolver.html#ab167a812619957f474a48b358b64eb1d">EnumeratedActionTextSerializer</a>.</p>
<p>To see a good example of the above, have a look at <a class="el" href="classtag_1_1TagTextSerializer.html">TagTextSerializer</a>.</p>
<h2><a class="anchor" id="implementing-changes"></a>
Implementing changes </h2>
<p>It is not mandatory for a <a class="el" href="classsolver_1_1Model.html">Model</a> implementation to deal with changes, but if you require this functionality, the following two core implementation details are the most important:</p>
<ul>
<li>A custom <a class="el" href="classsolver_1_1ModelChange.html">ModelChange</a> class, e.g. <a class="el" href="structtag_1_1TagChange.html">TagChange</a>. This class doesn't have any required methods, because it's up to each individual <a class="el" href="classsolver_1_1Model.html">Model</a> implementation to determine how it deals with changes. Note that if you implement <a class="el" href="classsolver_1_1ModelChange.html">ModelChange</a> you will likely also need to implement serialization methods, e.g. <a class="el" href="classtag_1_1TagTextSerializer.html#acc406902451a19c3c420ea2f5c93daaf">TagTextSerializer::saveModelChange</a> and <a class="el" href="classtag_1_1TagTextSerializer.html#ac2a68c270a347e2e5dbcc7bdc738667f">TagTextSerializer::loadModelChange</a></li>
<li>An implementation of <a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818">Model::applyChanges</a>, which performs two key functions:<ul>
<li>Updating the Model's black box generators in response to the changes.</li>
<li>Informing the Solver of the changes that have been applied. This is done via the <a class="el" href="classsolver_1_1StatePool.html">StatePool</a> interface, which can be used in conjunction with a custom <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> implementation, e.g. <a class="el" href="classsolver_1_1RTree.html">RTree</a>, in order to perform more intelligent queries. See <a class="el" href="classtag_1_1TagModel.html#aee78581d756decfeb7a7f8584151a8ff">TagModel::applyChanges</a> for an example implentation.</li>
</ul>
</li>
</ul>
<p>The <a class="el" href="classsolver_1_1Solver.html">Solver</a> handles model changes by using a <a class="el" href="classsolver_1_1HistoryCorrector.html">HistoryCorrector</a>, the default implementation of which is <a class="el" href="classsolver_1_1DefaultHistoryCorrector.html">DefaultHistoryCorrector</a>, which should work OK for any custom problem. However, in order to use this implementation you must also implement these methods of <a class="el" href="classsolver_1_1Model.html">Model</a>:</p>
<ul>
<li><a class="el" href="classsolver_1_1Model.html#a73fc7fe3f7ebe845604fac46adc0383b">Model::generateNextState</a> to generate states - an implicit definition of T(s, a, s')</li>
<li><a class="el" href="classsolver_1_1Model.html#a40e63ec3d653c9e42120e8690a311d4c">Model::generateObservation</a> to generate observations - an implicit definition of Z(a, o, s')</li>
<li><a class="el" href="classsolver_1_1Model.html#a57f002206fa228bf82cf0fb67037d7c4">Model::generateReward</a> to generate rewards - an implicit definition of R(s, a)</li>
</ul>
<p>These three methods are used instead of <a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">Model::generateStep</a> in order to avoid unnecessary recalculation, and to minize the extent to which new histories diverge from old ones due to re-randomization. To minimize such issues even further, you can use <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> and <a class="el" href="classsolver_1_1Model.html#ab63a02a646be252ec1bd3b2c6c1d9f14">Model::generateTransition</a>, which allows you to store extra information about a generated step. This can be used, for example, to store intermediate calculations, or generated random numbers. See the documentation of <a class="el" href="classsolver_1_1Model.html">Model</a> for greater detail.</p>
<h2><a class="anchor" id="generating-binaries-for-a-new-pomdp-model"></a>
Generating binaries for a new POMDP model </h2>
<p>For additional convenience, template methods to generate binaries for an individual problem are given in:</p>
<ul>
<li><a class="el" href="solve_8hpp.html">solve.hpp</a> &mdash; initial offline policy generation; see <a class="el" href="tag_2solve_8cpp_source.html">solve.cpp for Tag</a> for a usage example.</li>
<li><a class="el" href="simulate_8hpp.html">simulate.hpp</a> &mdash; simulation with online POMDP solution; see <a class="el" href="tag_2simulate_8cpp_source.html">simulate.cpp for Tag</a> for a usage example. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 7 2014 00:14:36 for TAPIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
