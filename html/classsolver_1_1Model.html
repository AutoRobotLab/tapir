<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ABT: solver::Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ABT
   </div>
   <div id="projectbrief">An online approximate POMDP solver that can adapt to changes in the POMDP model.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesolver.html">solver</a></li><li class="navelem"><a class="el" href="classsolver_1_1Model.html">Model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsolver_1_1Model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">solver::Model Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract class representing a black-box POMDP model for use by the ABT solver.  
 <a href="classsolver_1_1Model.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Model_8hpp_source.html">Model.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for solver::Model:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsolver_1_1Model.png" usemap="#solver::Model_map" alt=""/>
  <map id="solver::Model_map" name="solver::Model_map">
<area href="classshared_1_1ModelWithProgramOptions.html" title="A partial implementation of Model allowing for text-based parsing of various advanced search options..." alt="shared::ModelWithProgramOptions" shape="rect" coords="108,56,315,80"/>
<area href="classrocksample_1_1RockSampleModel.html" alt="rocksample::RockSampleModel" shape="rect" coords="0,112,207,136"/>
<area href="classtag_1_1TagModel.html" alt="tag::TagModel" shape="rect" coords="217,112,424,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsolver_1_1Model_1_1StepResult.html">StepResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the results of a complete step in the model, including the next state, observation, and reward, as well as any transition parameters used.  <a href="structsolver_1_1Model_1_1StepResult.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a97a038e67b7bbb59ed2a0d7b33c470d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a97a038e67b7bbb59ed2a0d7b33c470d0">Model</a> (std::string name, <a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *randGen, std::unique_ptr&lt; <a class="el" href="structsolver_1_1Options.html">Options</a> &gt; options)</td></tr>
<tr class="memdesc:a97a038e67b7bbb59ed2a0d7b33c470d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classsolver_1_1Model.html" title="An abstract class representing a black-box POMDP model for use by the ABT solver. ...">Model</a> with the given name, random engine, and the given configuration settings.  <a href="#a97a038e67b7bbb59ed2a0d7b33c470d0">More...</a><br/></td></tr>
<tr class="separator:a97a038e67b7bbb59ed2a0d7b33c470d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20afccd61c8f55833ce560efd58e9801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a20afccd61c8f55833ce560efd58e9801">getRandomGenerator</a> () const </td></tr>
<tr class="memdesc:a20afccd61c8f55833ce560efd58e9801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the random number generator used by this model.  <a href="#a20afccd61c8f55833ce560efd58e9801">More...</a><br/></td></tr>
<tr class="separator:a20afccd61c8f55833ce560efd58e9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9177e4ab34e4d512f0a5b8ac9a822a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsolver_1_1Options.html">Options</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a7d9177e4ab34e4d512f0a5b8ac9a822a">getOptions</a> () const </td></tr>
<tr class="memdesc:a7d9177e4ab34e4d512f0a5b8ac9a822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the configuration options for this model.  <a href="#a7d9177e4ab34e4d512f0a5b8ac9a822a">More...</a><br/></td></tr>
<tr class="separator:a7d9177e4ab34e4d512f0a5b8ac9a822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eb987c371dd354c7cf2816aae8999b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ad5eb987c371dd354c7cf2816aae8999b">getName</a> () const </td></tr>
<tr class="memdesc:ad5eb987c371dd354c7cf2816aae8999b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this problem.  <a href="#ad5eb987c371dd354c7cf2816aae8999b">More...</a><br/></td></tr>
<tr class="separator:ad5eb987c371dd354c7cf2816aae8999b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e62295cded9ac6e59ac46bbe98ba70c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c">sampleAnInitState</a> ()=0</td></tr>
<tr class="memdesc:a2e62295cded9ac6e59ac46bbe98ba70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples an initial state from the initial belief.  <a href="#a2e62295cded9ac6e59ac46bbe98ba70c">More...</a><br/></td></tr>
<tr class="separator:a2e62295cded9ac6e59ac46bbe98ba70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3fd2691ae717aa5cdf61fe32269f5c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a7c3fd2691ae717aa5cdf61fe32269f5c">sampleStateUninformed</a> ()=0</td></tr>
<tr class="memdesc:a7c3fd2691ae717aa5cdf61fe32269f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a state from a poorly-informed prior.  <a href="#a7c3fd2691ae717aa5cdf61fe32269f5c">More...</a><br/></td></tr>
<tr class="separator:a7c3fd2691ae717aa5cdf61fe32269f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaefbb5cafd6984d16d0e7972e96befd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#afaefbb5cafd6984d16d0e7972e96befd">isTerminal</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;state)=0</td></tr>
<tr class="memdesc:afaefbb5cafd6984d16d0e7972e96befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given state is terminal.  <a href="#afaefbb5cafd6984d16d0e7972e96befd">More...</a><br/></td></tr>
<tr class="separator:afaefbb5cafd6984d16d0e7972e96befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac935e5b653acc3a19dd5bc963bf4a14d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsolver_1_1Model_1_1StepResult.html">StepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">generateStep</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action)=0</td></tr>
<tr class="memdesc:ac935e5b653acc3a19dd5bc963bf4a14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a full <a class="el" href="structsolver_1_1Model_1_1StepResult.html" title="Represents the results of a complete step in the model, including the next state, observation...">StepResult</a>, including the next state, an observation, and the reward, as well as any transition parameters used.  <a href="#ac935e5b653acc3a19dd5bc963bf4a14d">More...</a><br/></td></tr>
<tr class="separator:ac935e5b653acc3a19dd5bc963bf4a14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a02a646be252ec1bd3b2c6c1d9f14"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ab63a02a646be252ec1bd3b2c6c1d9f14">generateTransition</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action)</td></tr>
<tr class="memdesc:ab63a02a646be252ec1bd3b2c6c1d9f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the parameters for a next-state transition, if any are being used.  <a href="#ab63a02a646be252ec1bd3b2c6c1d9f14">More...</a><br/></td></tr>
<tr class="separator:ab63a02a646be252ec1bd3b2c6c1d9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fc7fe3f7ebe845604fac46adc0383b"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a73fc7fe3f7ebe845604fac46adc0383b">generateNextState</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *transitionParameters)</td></tr>
<tr class="memdesc:a73fc7fe3f7ebe845604fac46adc0383b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the next state, based on the state and action, and, if used, the transition parameters.  <a href="#a73fc7fe3f7ebe845604fac46adc0383b">More...</a><br/></td></tr>
<tr class="separator:a73fc7fe3f7ebe845604fac46adc0383b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e63ec3d653c9e42120e8690a311d4c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a40e63ec3d653c9e42120e8690a311d4c">generateObservation</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const *state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *transitionParameters, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;nextState)</td></tr>
<tr class="memdesc:a40e63ec3d653c9e42120e8690a311d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an observation, given the action and resulting next state; optionally, the previous state and the transition parameters can also be used.  <a href="#a40e63ec3d653c9e42120e8690a311d4c">More...</a><br/></td></tr>
<tr class="separator:a40e63ec3d653c9e42120e8690a311d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f002206fa228bf82cf0fb67037d7c4"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a57f002206fa228bf82cf0fb67037d7c4">generateReward</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *transitionParameters, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const *nextState)</td></tr>
<tr class="memdesc:a57f002206fa228bf82cf0fb67037d7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reward for the given state, action; optionally this also includes transition parameters and the next state - if they aren't being used it is OK to use nullptr for those inputs.  <a href="#a57f002206fa228bf82cf0fb67037d7c4">More...</a><br/></td></tr>
<tr class="separator:a57f002206fa228bf82cf0fb67037d7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccf7e6bae8558086cf276017c9a9818"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818">applyChanges</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1ModelChange.html">ModelChange</a> &gt;&gt; const &amp;changes, <a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="memdesc:aaccf7e6bae8558086cf276017c9a9818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a number of changes to the model, and (if provided) to the given solver.  <a href="#aaccf7e6bae8558086cf276017c9a9818">More...</a><br/></td></tr>
<tr class="separator:aaccf7e6bae8558086cf276017c9a9818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bf7b0167216caaa37dbc5e79273a8b"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a40bf7b0167216caaa37dbc5e79273a8b">generateParticles</a> (<a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *previousBelief, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action, <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const * &gt; const &amp;previousParticles)</td></tr>
<tr class="memdesc:a40bf7b0167216caaa37dbc5e79273a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates new state particles based on the state particles of the previous node, as well as on the action and observation.  <a href="#a40bf7b0167216caaa37dbc5e79273a8b">More...</a><br/></td></tr>
<tr class="separator:a40bf7b0167216caaa37dbc5e79273a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc0aa58463c5da7385824e08a242dc5"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a0dc0aa58463c5da7385824e08a242dc5">generateParticles</a> (<a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *previousBelief, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action, <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> const &amp;obs, long nParticles)</td></tr>
<tr class="memdesc:a0dc0aa58463c5da7385824e08a242dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates new state particles based only on the previous action and observation, assuming a poorly-informed prior over previous states.  <a href="#a0dc0aa58463c5da7385824e08a242dc5">More...</a><br/></td></tr>
<tr class="separator:a0dc0aa58463c5da7385824e08a242dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98d2be0d9d93c7400163df7c40115a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ae98d2be0d9d93c7400163df7c40115a8">drawEnv</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:ae98d2be0d9d93c7400163df7c40115a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the environment map (independent of the current state or belief) onto the given output stream.  <a href="#ae98d2be0d9d93c7400163df7c40115a8">More...</a><br/></td></tr>
<tr class="separator:ae98d2be0d9d93c7400163df7c40115a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bfb5cef2839f7e20f670e37f0b643b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a48bfb5cef2839f7e20f670e37f0b643b">drawSimulationState</a> (<a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> const *belief, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;state, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a48bfb5cef2839f7e20f670e37f0b643b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the current belief and/or the actual current state in the context of the overall map onto the given output stream.  <a href="#a48bfb5cef2839f7e20f670e37f0b643b">More...</a><br/></td></tr>
<tr class="separator:a48bfb5cef2839f7e20f670e37f0b643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a73bc8bd8d983464d6717218f60ba1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacesolver.html#a2652743b2b118d001615cc27ed0ce636">HeuristicFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a09a73bc8bd8d983464d6717218f60ba1">getHeuristicFunction</a> ()</td></tr>
<tr class="memdesc:a09a73bc8bd8d983464d6717218f60ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function that approximates the value of a history entry based on the history and/or an estimate using a single state.  <a href="#a09a73bc8bd8d983464d6717218f60ba1">More...</a><br/></td></tr>
<tr class="separator:a09a73bc8bd8d983464d6717218f60ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458b46cd30555b7cca121f383831a2af"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a458b46cd30555b7cca121f383831a2af">getRolloutAction</a> (<a class="el" href="classsolver_1_1HistoryEntry.html">HistoryEntry</a> const *entry, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const *state, <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> const *data)</td></tr>
<tr class="memdesc:a458b46cd30555b7cca121f383831a2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a rollout action to be use, which can be based on the current state, the current belief, and/or the history.  <a href="#a458b46cd30555b7cca121f383831a2af">More...</a><br/></td></tr>
<tr class="separator:a458b46cd30555b7cca121f383831a2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9099de4b2b73a8b55a916a5ba827401"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#aa9099de4b2b73a8b55a916a5ba827401">createStateIndex</a> ()</td></tr>
<tr class="memdesc:aa9099de4b2b73a8b55a916a5ba827401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsolver_1_1StateIndex.html" title="An interface class for storing states and looking them up in custom ways. ">StateIndex</a>, which manages searching for states that have been used in a <a class="el" href="classsolver_1_1StatePool.html" title="A class to hold all of the states encountered by the ABT algorithm. ">StatePool</a>.  <a href="#aa9099de4b2b73a8b55a916a5ba827401">More...</a><br/></td></tr>
<tr class="separator:aa9099de4b2b73a8b55a916a5ba827401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680abcdce70007452d7148e571d417d3"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1HistoryCorrector.html">HistoryCorrector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a680abcdce70007452d7148e571d417d3">createHistoryCorrector</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="memdesc:a680abcdce70007452d7148e571d417d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsolver_1_1HistoryCorrector.html" title="An abstract base class for correcting history sequences that have been affected by changes...">HistoryCorrector</a> for this <a class="el" href="classsolver_1_1Model.html" title="An abstract class representing a black-box POMDP model for use by the ABT solver. ...">Model</a>.  <a href="#a680abcdce70007452d7148e571d417d3">More...</a><br/></td></tr>
<tr class="separator:a680abcdce70007452d7148e571d417d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153e447124946743272c156ee40e7024"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a153e447124946743272c156ee40e7024">createActionPool</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)=0</td></tr>
<tr class="memdesc:a153e447124946743272c156ee40e7024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classsolver_1_1ActionPool.html" title="An interface class which is a factory for creating action mappings. ">ActionPool</a>, which manages actions and creates ActionMappings, for the given solver.  <a href="#a153e447124946743272c156ee40e7024">More...</a><br/></td></tr>
<tr class="separator:a153e447124946743272c156ee40e7024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3037fa770c7f3c634359852d1e6578dd"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1ObservationPool.html">ObservationPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a3037fa770c7f3c634359852d1e6578dd">createObservationPool</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="memdesc:a3037fa770c7f3c634359852d1e6578dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classsolver_1_1ObservationPool.html" title="An interface class which is a factory for creating observation mappings. ">ObservationPool</a>, which manages observations and creates ObservationMappings, for the given solver.  <a href="#a3037fa770c7f3c634359852d1e6578dd">More...</a><br/></td></tr>
<tr class="separator:a3037fa770c7f3c634359852d1e6578dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9255f8536dc82bdbbf22e9d2f8b20da9"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1SearchStrategy.html">SearchStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a9255f8536dc82bdbbf22e9d2f8b20da9">createSearchStrategy</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="memdesc:a9255f8536dc82bdbbf22e9d2f8b20da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a search strategy for use by the given solver.  <a href="#a9255f8536dc82bdbbf22e9d2f8b20da9">More...</a><br/></td></tr>
<tr class="separator:a9255f8536dc82bdbbf22e9d2f8b20da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aad90d25bafab33624da97a61fc8546"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1EstimationStrategy.html">EstimationStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a7aad90d25bafab33624da97a61fc8546">createEstimationStrategy</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="memdesc:a7aad90d25bafab33624da97a61fc8546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a strategy for estimating the value of belief nodes, for backprop, for the given solver.  <a href="#a7aad90d25bafab33624da97a61fc8546">More...</a><br/></td></tr>
<tr class="separator:a7aad90d25bafab33624da97a61fc8546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670f91cb5cf3fc5b44be21ddfe7ecace"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a670f91cb5cf3fc5b44be21ddfe7ecace">createRootHistoricalData</a> ()</td></tr>
<tr class="memdesc:a670f91cb5cf3fc5b44be21ddfe7ecace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the historical data for the root node.  <a href="#a670f91cb5cf3fc5b44be21ddfe7ecace">More...</a><br/></td></tr>
<tr class="separator:a670f91cb5cf3fc5b44be21ddfe7ecace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a047dea9be5fd302e30456dc13e490"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#af2a047dea9be5fd302e30456dc13e490">createSerializer</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="memdesc:af2a047dea9be5fd302e30456dc13e490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsolver_1_1Serializer.html" title="An abstract base class to perform the function of serializing an ABT solver instance. ">Serializer</a> for the given solver.  <a href="#af2a047dea9be5fd302e30456dc13e490">More...</a><br/></td></tr>
<tr class="separator:af2a047dea9be5fd302e30456dc13e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract class representing a black-box POMDP model for use by the ABT solver. </p>
<p>The key methods are:</p>
<ul>
<li><a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c" title="Samples an initial state from the initial belief. ">sampleAnInitState()</a> - samples a new state from the initial belief.</li>
<li><a class="el" href="classsolver_1_1Model.html#afaefbb5cafd6984d16d0e7972e96befd" title="Returns true iff the given state is terminal. ">isTerminal()</a> - returns true iff the given state is terminal.</li>
<li><a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d" title="Generates a full StepResult, including the next state, an observation, and the reward, as well as any transition parameters used. ">generateStep()</a> - the key method representing the generative model; basically, it does (s, a) =&gt; (o, r, s')</li>
<li><a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818" title="Applies a number of changes to the model, and (if provided) to the given solver. ">applyChanges()</a> - applies changes to the model, and interfaces with the <a class="el" href="classsolver_1_1Solver.html" title="The core class of the ABT algorithm. ">Solver</a> in order to determine how the policy is affected by the model changes.</li>
<li><a class="el" href="classsolver_1_1Model.html#a40bf7b0167216caaa37dbc5e79273a8b" title="Generates new state particles based on the state particles of the previous node, as well as on the ac...">generateParticles()</a> - these two methods define an explicit particle filtering approach, which allows the ABT algorithm to replenish its particles if the simple act of generating histories has not generated a sufficient number of particles for the current belief. The default implementation is quite general, but also relatively slow as it uses rejection sampling. Custom implementations should be provided for efficiency.</li>
<li><a class="el" href="classsolver_1_1Model.html#a09a73bc8bd8d983464d6717218f60ba1" title="Returns the function that approximates the value of a history entry based on the history and/or an es...">getHeuristicFunction()</a> - this defines a heuristic function that will be applied to the end of a history sequence that did not reach a terminal state. By default this is simply a function that returns zero.</li>
<li><a class="el" href="classsolver_1_1Model.html#a153e447124946743272c156ee40e7024" title="Creates an ActionPool, which manages actions and creates ActionMappings, for the given solver...">createActionPool()</a> - this defines the way in which actions are mapped out inside the policy tree, and also which actions the ABT solver will attempt, and in which order.</li>
</ul>
<p>For the purposes of more subtle generation, ABT allows for a more incremental approach to the generative model. In particular, we introduce optional "transition parameters", which can serve the following key purposes:</p>
<ul>
<li>Encompassing any and all "randomness" that features in a state transition. This has two key advantages:<ul>
<li>When changing histories, we can minimize the number of histories that "diverge" from the original path.</li>
<li>This can also be used for various variance reduction techniques, which are well documented in the literature.</li>
</ul>
</li>
<li>Storing intermediate information about the generative calculations that would otherwise be relatively expensive to calculate.</li>
</ul>
<p>The generative model is therefore further broken down into the following methods; some of these parameters are optional and nullptr can be used for those values if they are not in use. In the summary below, optional parameters are surrounded by square brackets [].</p>
<ul>
<li><a class="el" href="classsolver_1_1Model.html#ab63a02a646be252ec1bd3b2c6c1d9f14" title="Generates the parameters for a next-state transition, if any are being used. ">generateTransition()</a> - (s, a) =&gt; [x]</li>
<li><a class="el" href="classsolver_1_1Model.html#a73fc7fe3f7ebe845604fac46adc0383b" title="Generates the next state, based on the state and action, and, if used, the transition parameters...">generateNextState()</a> - (s, a, [x]) =&gt; s'</li>
<li><a class="el" href="classsolver_1_1Model.html#a40e63ec3d653c9e42120e8690a311d4c" title="Generates an observation, given the action and resulting next state; optionally, the previous state a...">generateObservation()</a> - ([s], a, [x], s') =&gt; o</li>
<li><a class="el" href="classsolver_1_1Model.html#a57f002206fa228bf82cf0fb67037d7c4" title="Returns the reward for the given state, action; optionally this also includes transition parameters a...">generateReward()</a> - (s, a, [x], [s']) =&gt; r </li>
</ul>

<p>Definition at line <a class="el" href="Model_8hpp_source.html#l00086">86</a> of file <a class="el" href="Model_8hpp_source.html">Model.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97a038e67b7bbb59ed2a0d7b33c470d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">solver::Model::Model </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>randGen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="structsolver_1_1Options.html">Options</a> &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classsolver_1_1Model.html" title="An abstract class representing a black-box POMDP model for use by the ABT solver. ...">Model</a> with the given name, random engine, and the given configuration settings. </p>
<p>Note that the options passed in will most typically be a subclass of the base <a class="el" href="structsolver_1_1Options.html" title="The base Options class for the ABT solver. ">Options</a> class, which allows for problem-specific configuration settings in a convenient way. </p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00042">42</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaccf7e6bae8558086cf276017c9a9818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Model::applyChanges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1ModelChange.html">ModelChange</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a number of changes to the model, and (if provided) to the given solver. </p>
<p>This is the core method that is used for the <a class="el" href="classsolver_1_1Model.html" title="An abstract class representing a black-box POMDP model for use by the ABT solver. ...">Model</a> to inform the <a class="el" href="classsolver_1_1Solver.html" title="The core class of the ABT algorithm. ">Solver</a> of which states are affected, and hence need to be updated in whichever history sequences they occur. This should be done via the <a class="el" href="classsolver_1_1Solver.html" title="The core class of the ABT algorithm. ">Solver</a>'s <a class="el" href="classsolver_1_1StatePool.html" title="A class to hold all of the states encountered by the ABT algorithm. ">StatePool</a> and <a class="el" href="classsolver_1_1StateIndex.html" title="An interface class for storing states and looking them up in custom ways. ">StateIndex</a>.</p>
<p>Since handling of changes is not mandatory, this method does nothing by default. However, if you do implement it, you must also implement <a class="el" href="classsolver_1_1Model.html#a73fc7fe3f7ebe845604fac46adc0383b" title="Generates the next state, based on the state and action, and, if used, the transition parameters...">generateNextState()</a>, <a class="el" href="classsolver_1_1Model.html#a40e63ec3d653c9e42120e8690a311d4c" title="Generates an observation, given the action and resulting next state; optionally, the previous state a...">generateObservation()</a>, and <a class="el" href="classsolver_1_1Model.html#a57f002206fa228bf82cf0fb67037d7c4" title="Returns the reward for the given state, action; optionally this also includes transition parameters a...">generateReward()</a>. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a3675c790d995c45744f6e302b8610a35">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#aee78581d756decfeb7a7f8584151a8ff">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00095">95</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a153e447124946743272c156ee40e7024"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a>&gt; solver::Model::createActionPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classsolver_1_1ActionPool.html" title="An interface class which is a factory for creating action mappings. ">ActionPool</a>, which manages actions and creates ActionMappings, for the given solver. </p>
<p>No default implementation is given, because there is no simple, general-purpose action mapping class. This is because the way in which actions are selected within the search tree depends strongly on the way in which the action space is specified.</p>
<p>However, for most purposes the EnumeratedActionMapping class should work well. This requires that the actions be enumerated [0, ..., nActions - 1], and that each action must be able to return its action number. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a52f7b73c5f81b116d3fca37bc5c80ece">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a6fadc5231a38f5d332c8a9dc761a441e">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a7aad90d25bafab33624da97a61fc8546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1EstimationStrategy.html">EstimationStrategy</a> &gt; solver::Model::createEstimationStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a strategy for estimating the value of belief nodes, for backprop, for the given solver. </p>
<p>The default approach is to simply take the average value of the estimated Q(s, a) values, weighted by the number of visits for each action - this is equivalent to the average value of all of the histories that go through this node.</p>
<p>This is a general-purpose approach which should converge for any problem as long as it is used with a search strategy that uses a UCB-like algorithm. </p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#a1769cce7f4d1d801bf0a8912d660df52">shared::ModelWithProgramOptions</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00197">197</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a680abcdce70007452d7148e571d417d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1HistoryCorrector.html">HistoryCorrector</a> &gt; solver::Model::createHistoryCorrector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classsolver_1_1HistoryCorrector.html" title="An abstract base class for correcting history sequences that have been affected by changes...">HistoryCorrector</a> for this <a class="el" href="classsolver_1_1Model.html" title="An abstract class representing a black-box POMDP model for use by the ABT solver. ...">Model</a>. </p>
<p>By default, this simply makes an instance of <a class="el" href="classsolver_1_1DefaultHistoryCorrector.html" title="A default HistoryCorrector implementation which should work quite well regardless of the specific pro...">DefaultHistoryCorrector</a>, which should work for pretty much all POMDP problems. </p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#a736662f55f6f8887e50f643d4fadbd80">shared::ModelWithProgramOptions</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00179">179</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3037fa770c7f3c634359852d1e6578dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1ObservationPool.html">ObservationPool</a> &gt; solver::Model::createObservationPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classsolver_1_1ObservationPool.html" title="An interface class which is a factory for creating observation mappings. ">ObservationPool</a>, which manages observations and creates ObservationMappings, for the given solver. </p>
<p>The default implementation is <a class="el" href="classsolver_1_1DiscreteObservationPool.html" title="An implementation of the ObservationPool interface that is based on a discrete observation space...">DiscreteObservationPool</a>, which stores the observations for each <a class="el" href="classsolver_1_1ActionNode.html" title="The base level interface used by the solver to store the results of taking a specific action from a s...">ActionNode</a> in a hashtable. This should be effective for any problem with a discrete observation space. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#aac57f2b88b70d6998eed6bfe48e41ba1">rocksample::RockSampleModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00184">184</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a670f91cb5cf3fc5b44be21ddfe7ecace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> &gt; solver::Model::createRootHistoricalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the historical data for the root node. </p>
<p>By default this returns a null pointer, as the <a class="el" href="classsolver_1_1HistoricalData.html" title="An abstract base class for history-based heuristic info; each HistoricalData will be owned by a singl...">HistoricalData</a> interface is optional. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a192d1c04c9ead1ebfd393c9b1a443510">rocksample::RockSampleModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00202">202</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9255f8536dc82bdbbf22e9d2f8b20da9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1SearchStrategy.html">SearchStrategy</a> &gt; solver::Model::createSearchStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a search strategy for use by the given solver. </p>
<p>The default strategy is simply a combination of UCB, in conjunction with applying the default heuristic function implemented by this model to the resulting state as soon as a new node in the policy tree is reached.</p>
<p>Note that the default strategy simply uses a UCB coefficient of 1.0 - if you need to change this coefficient value, simply override this method. </p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#a87a62ae1676eb8c4d7186dda8fa4a97f">shared::ModelWithProgramOptions</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00189">189</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2a047dea9be5fd302e30456dc13e490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> &gt; solver::Model::createSerializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classsolver_1_1Serializer.html" title="An abstract base class to perform the function of serializing an ABT solver instance. ">Serializer</a> for the given solver. </p>
<p>By default this returns a null pointer. However, if you require serialization of the state of an ABT solver, you must implement a custom <a class="el" href="classsolver_1_1Serializer.html" title="An abstract base class to perform the function of serializing an ABT solver instance. ">Serializer</a> which will properly serialize the various clases you have implemented as part of your POMDP model. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a827e08611510470f8a8b0023deeae460">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ae11259dc1b4cf3426459ffd1d6885a84">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00207">207</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9099de4b2b73a8b55a916a5ba827401"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> &gt; solver::Model::createStateIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classsolver_1_1StateIndex.html" title="An interface class for storing states and looking them up in custom ways. ">StateIndex</a>, which manages searching for states that have been used in a <a class="el" href="classsolver_1_1StatePool.html" title="A class to hold all of the states encountered by the ABT algorithm. ">StatePool</a>. </p>
<p>By default, this method uses an R*-Tree, as implemented in libspatialindex, in order to allow range-based queries for the states. </p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00174">174</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae98d2be0d9d93c7400163df7c40115a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Model::drawEnv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the environment map (independent of the current state or belief) onto the given output stream. </p>
<p>Does nothing by default. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a7ceb9c80046ef33d7325f05bf2c5b94f">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a888ccb2307023d84485eace5f0a1ab8c">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00150">150</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48bfb5cef2839f7e20f670e37f0b643b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Model::drawSimulationState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> const *&#160;</td>
          <td class="paramname"><em>belief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the current belief and/or the actual current state in the context of the overall map onto the given output stream. </p>
<p>Does nothing by default. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a6ffb03c676d9738381124d43717ae655">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a3950e8a4df86b9bebd131337c396572d">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00153">153</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73fc7fe3f7ebe845604fac46adc0383b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt; solver::Model::generateNextState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the next state, based on the state and action, and, if used, the transition parameters. </p>
<p>This method is only mandatory if you implement the <a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818" title="Applies a number of changes to the model, and (if provided) to the given solver. ">applyChanges()</a> method. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#ab632e79e36a246f393e759e3e0bc83c9">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a0453e43cf10a8ff15d98aa40c8abe908">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00066">66</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40e63ec3d653c9e42120e8690a311d4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> &gt; solver::Model::generateObservation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an observation, given the action and resulting next state; optionally, the previous state and the transition parameters can also be used. </p>
<p>This method is only mandatory if you implement the <a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818" title="Applies a number of changes to the model, and (if provided) to the given solver. ">applyChanges()</a> method. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a1fff87dc9eb30bd1450a16b467445ba6">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a790d25b10b9b46b1e5d735e1576b2f40">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00074">74</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40bf7b0167216caaa37dbc5e79273a8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt; &gt; solver::Model::generateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *&#160;</td>
          <td class="paramname"><em>previousBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>previousParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates new state particles based on the state particles of the previous node, as well as on the action and observation. </p>
<p>The default implementation uses rejection sampling, but this can be overridden to provide a more efficient implementation. </p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00101">101</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0dc0aa58463c5da7385824e08a242dc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt; &gt; solver::Model::generateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *&#160;</td>
          <td class="paramname"><em>previousBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates new state particles based only on the previous action and observation, assuming a poorly-informed prior over previous states. </p>
<p>This should only be used if the previous belief turns out to be incompatible with the current observation.</p>
<p>The default implementation uses rejection sampling, but this can be overridden to provide a more efficient implementation. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a7f0c264da6a90d17b477547b0772589d">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#acc9c7e67068e6a1a9b34c6b0912085f0">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00126">126</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57f002206fa228bf82cf0fb67037d7c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double solver::Model::generateReward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const *&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reward for the given state, action; optionally this also includes transition parameters and the next state - if they aren't being used it is OK to use nullptr for those inputs. </p>
<p>This method is only mandatory if you implement the <a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818" title="Applies a number of changes to the model, and (if provided) to the given solver. ">applyChanges()</a> method. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a10878f20df5e89acc1cdb878e9eb663b">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#aed6c8471934ef7c719c315f694ff6770">tag::TagModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00083">83</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac935e5b653acc3a19dd5bc963bf4a14d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsolver_1_1Model_1_1StepResult.html">StepResult</a> solver::Model::generateStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a full <a class="el" href="structsolver_1_1Model_1_1StepResult.html" title="Represents the results of a complete step in the model, including the next state, observation...">StepResult</a>, including the next state, an observation, and the reward, as well as any transition parameters used. </p>
<p>For convenience, the action taken is also included in the result, as well as a flag for whether or not the resulting next state is terminal. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a83ddd528d6cce7ef94acb1e20bea5290">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ad102851658bd8a0998fe05c50fb17473">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="ab63a02a646be252ec1bd3b2c6c1d9f14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> &gt; solver::Model::generateTransition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the parameters for a next-state transition, if any are being used. </p>
<p>This method is optional - the default implementation simply returns nullptr. </p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00060">60</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09a73bc8bd8d983464d6717218f60ba1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesolver.html#a2652743b2b118d001615cc27ed0ce636">HeuristicFunction</a> solver::Model::getHeuristicFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function that approximates the value of a history entry based on the history and/or an estimate using a single state. </p>
<p>The default implementation simply returns zero.</p>
<p>By default, this is simply a function that returns zero for every state.</p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#a25ce114391f7b099d906ddb90d0b38c5">shared::ModelWithProgramOptions</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00160">160</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5eb987c371dd354c7cf2816aae8999b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string solver::Model::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of this problem. </p>

</div>
</div>
<a class="anchor" id="a7d9177e4ab34e4d512f0a5b8ac9a822a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsolver_1_1Options.html">Options</a> const * solver::Model::getOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the configuration options for this model. </p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00053">53</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20afccd61c8f55833ce560efd58e9801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> * solver::Model::getRandomGenerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the random number generator used by this model. </p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00049">49</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a458b46cd30555b7cca121f383831a2af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> &gt; solver::Model::getRolloutAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1HistoryEntry.html">HistoryEntry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a rollout action to be use, which can be based on the current state, the current belief, and/or the history. </p>
<p>Optional; not implemented.</p>
<p>By default, this method simply returns nullptr, because rollouts are not used at all by the default search strategy - instead it simply uses the heuristic function.</p>
<p>Providing the <a class="el" href="classsolver_1_1HistoryEntry.html" title="Represents a single entry in a sequence. ">HistoryEntry</a> allows access to the history sequence and belief associated with the history entry, allowing for more intelligent POMDP-aware heuristics.</p>
<p>Providing the <a class="el" href="classsolver_1_1HistoricalData.html" title="An abstract base class for history-based heuristic info; each HistoricalData will be owned by a singl...">HistoricalData</a> allows for convenient history-based rollout policies that can be efficiently calculated per belief node rather than requiring explicit calculation from the entire history sequence.</p>
<p>Providing the current state also allows for optimistic rollout strategies based on perfect information.</p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a43c68168bde5bf7edea9562be2f37825">rocksample::RockSampleModel</a>.</p>

<p>Definition at line <a class="el" href="Model_8cpp_source.html#l00168">168</a> of file <a class="el" href="Model_8cpp_source.html">Model.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afaefbb5cafd6984d16d0e7972e96befd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool solver::Model::isTerminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the given state is terminal. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a484a616e2df44e9d9a94c655c4c6e119">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ac4ab766ca6879f285b91bb5fce68b5e0">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a2e62295cded9ac6e59ac46bbe98ba70c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a>&gt; solver::Model::sampleAnInitState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Samples an initial state from the initial belief. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#afc7b64bbf56a9a0a95543d57e9a2f739">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ae255eae8542528670096bd06736f88fa">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a7c3fd2691ae717aa5cdf61fe32269f5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a>&gt; solver::Model::sampleStateUninformed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Samples a state from a poorly-informed prior. </p>
<p>This is used by the provided default implementation of the second <a class="el" href="classsolver_1_1Model.html#a40bf7b0167216caaa37dbc5e79273a8b" title="Generates new state particles based on the state particles of the previous node, as well as on the ac...">generateParticles()</a> method. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a81c4bb994b8fe0731992c4e0add77163">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a132f33203b738ffe681701e0d65607e7">tag::TagModel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/solver/abstract-problem/<a class="el" href="Model_8hpp_source.html">Model.hpp</a></li>
<li>src/solver/abstract-problem/<a class="el" href="Model_8cpp_source.html">Model.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2014 21:54:11 for ABT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
