<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ABT: solver::Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ABT
   </div>
   <div id="projectbrief">An online approximate POMDP solver that can adapt to changes in the POMDP model.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesolver.html">solver</a></li><li class="navelem"><a class="el" href="classsolver_1_1Model.html">Model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsolver_1_1Model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">solver::Model Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Model_8hpp_source.html">Model.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for solver::Model:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsolver_1_1Model.png" usemap="#solver::Model_map" alt=""/>
  <map id="solver::Model_map" name="solver::Model_map">
<area href="classshared_1_1ModelWithProgramOptions.html" alt="shared::ModelWithProgramOptions" shape="rect" coords="108,56,315,80"/>
<area href="classrocksample_1_1RockSampleModel.html" alt="rocksample::RockSampleModel" shape="rect" coords="0,112,207,136"/>
<area href="classtag_1_1TagModel.html" alt="tag::TagModel" shape="rect" coords="217,112,424,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsolver_1_1Model_1_1StepResult.html">StepResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a97a038e67b7bbb59ed2a0d7b33c470d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a97a038e67b7bbb59ed2a0d7b33c470d0">Model</a> (std::string name, RandomGenerator *randGen, std::unique_ptr&lt; <a class="el" href="structsolver_1_1Options.html">Options</a> &gt; options)</td></tr>
<tr class="separator:a97a038e67b7bbb59ed2a0d7b33c470d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509408a911a8f95111cdea97f242a195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a509408a911a8f95111cdea97f242a195"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_NO_COPY_OR_MOVE</b> (<a class="el" href="classsolver_1_1Model.html">Model</a>)</td></tr>
<tr class="separator:a509408a911a8f95111cdea97f242a195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20afccd61c8f55833ce560efd58e9801"><td class="memItemLeft" align="right" valign="top">RandomGenerator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a20afccd61c8f55833ce560efd58e9801">getRandomGenerator</a> () const </td></tr>
<tr class="separator:a20afccd61c8f55833ce560efd58e9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9177e4ab34e4d512f0a5b8ac9a822a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsolver_1_1Options.html">Options</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a7d9177e4ab34e4d512f0a5b8ac9a822a">getOptions</a> () const </td></tr>
<tr class="separator:a7d9177e4ab34e4d512f0a5b8ac9a822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eb987c371dd354c7cf2816aae8999b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ad5eb987c371dd354c7cf2816aae8999b">getName</a> () const </td></tr>
<tr class="separator:ad5eb987c371dd354c7cf2816aae8999b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e62295cded9ac6e59ac46bbe98ba70c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c">sampleAnInitState</a> ()=0</td></tr>
<tr class="separator:a2e62295cded9ac6e59ac46bbe98ba70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8b0b629913785f450aa07740b3eda1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a4c8b0b629913785f450aa07740b3eda1">sampleStateUniform</a> ()=0</td></tr>
<tr class="separator:a4c8b0b629913785f450aa07740b3eda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaefbb5cafd6984d16d0e7972e96befd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#afaefbb5cafd6984d16d0e7972e96befd">isTerminal</a> (<a class="el" href="classsolver_1_1Point.html">State</a> const &amp;state)=0</td></tr>
<tr class="separator:afaefbb5cafd6984d16d0e7972e96befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac935e5b653acc3a19dd5bc963bf4a14d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsolver_1_1Model_1_1StepResult.html">StepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">generateStep</a> (<a class="el" href="classsolver_1_1Point.html">State</a> const &amp;state, <a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;action)=0</td></tr>
<tr class="separator:ac935e5b653acc3a19dd5bc963bf4a14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a02a646be252ec1bd3b2c6c1d9f14"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ab63a02a646be252ec1bd3b2c6c1d9f14">generateTransition</a> (<a class="el" href="classsolver_1_1Point.html">State</a> const &amp;state, <a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;action)</td></tr>
<tr class="separator:ab63a02a646be252ec1bd3b2c6c1d9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1fb5d2be61c81088c5ea575c8ae30e"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a3e1fb5d2be61c81088c5ea575c8ae30e">generateNextState</a> (<a class="el" href="classsolver_1_1Point.html">State</a> const &amp;state, <a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *transitionParameters)=0</td></tr>
<tr class="separator:a3e1fb5d2be61c81088c5ea575c8ae30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae480df8a207b5fb68cdcc1b17b40768b"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1Point.html">Observation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ae480df8a207b5fb68cdcc1b17b40768b">generateObservation</a> (<a class="el" href="classsolver_1_1Point.html">State</a> const *state, <a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *transitionParameters, <a class="el" href="classsolver_1_1Point.html">State</a> const &amp;nextState)=0</td></tr>
<tr class="separator:ae480df8a207b5fb68cdcc1b17b40768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baf600ecf5379e0f9e2c0db86c62c34"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a8baf600ecf5379e0f9e2c0db86c62c34">generateReward</a> (<a class="el" href="classsolver_1_1Point.html">State</a> const &amp;state, <a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *transitionParameters, <a class="el" href="classsolver_1_1Point.html">State</a> const *nextState)=0</td></tr>
<tr class="separator:a8baf600ecf5379e0f9e2c0db86c62c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccf7e6bae8558086cf276017c9a9818"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818">applyChanges</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1ModelChange.html">ModelChange</a> &gt;&gt; const &amp;changes, <a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="separator:aaccf7e6bae8558086cf276017c9a9818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bf7b0167216caaa37dbc5e79273a8b"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a40bf7b0167216caaa37dbc5e79273a8b">generateParticles</a> (<a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *previousBelief, <a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;action, <a class="el" href="classsolver_1_1Point.html">Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="classsolver_1_1Point.html">State</a> const * &gt; const &amp;previousParticles)</td></tr>
<tr class="separator:a40bf7b0167216caaa37dbc5e79273a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc0aa58463c5da7385824e08a242dc5"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a0dc0aa58463c5da7385824e08a242dc5">generateParticles</a> (<a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *previousBelief, <a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;action, <a class="el" href="classsolver_1_1Point.html">Observation</a> const &amp;obs, long nParticles)</td></tr>
<tr class="separator:a0dc0aa58463c5da7385824e08a242dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98d2be0d9d93c7400163df7c40115a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ae98d2be0d9d93c7400163df7c40115a8">drawEnv</a> (std::ostream &amp;)</td></tr>
<tr class="separator:ae98d2be0d9d93c7400163df7c40115a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bfb5cef2839f7e20f670e37f0b643b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a48bfb5cef2839f7e20f670e37f0b643b">drawSimulationState</a> (<a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> const *belief, <a class="el" href="classsolver_1_1Point.html">State</a> const &amp;state, std::ostream &amp;os)</td></tr>
<tr class="separator:a48bfb5cef2839f7e20f670e37f0b643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080de609bc622ed1b2985a9c73cca392"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacesolver.html#ab9e1b50ecb46556312c91f9349be3966">Heuristic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a080de609bc622ed1b2985a9c73cca392">getHeuristicFunction</a> ()</td></tr>
<tr class="separator:a080de609bc622ed1b2985a9c73cca392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458b46cd30555b7cca121f383831a2af"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">Action</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a458b46cd30555b7cca121f383831a2af">getRolloutAction</a> (<a class="el" href="classsolver_1_1HistoryEntry.html">HistoryEntry</a> const *entry, <a class="el" href="classsolver_1_1Point.html">State</a> const *state, <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> const *data)</td></tr>
<tr class="separator:a458b46cd30555b7cca121f383831a2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9099de4b2b73a8b55a916a5ba827401"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#aa9099de4b2b73a8b55a916a5ba827401">createStateIndex</a> ()</td></tr>
<tr class="separator:aa9099de4b2b73a8b55a916a5ba827401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680abcdce70007452d7148e571d417d3"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1HistoryCorrector.html">HistoryCorrector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a680abcdce70007452d7148e571d417d3">createHistoryCorrector</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="separator:a680abcdce70007452d7148e571d417d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153e447124946743272c156ee40e7024"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a153e447124946743272c156ee40e7024">createActionPool</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)=0</td></tr>
<tr class="separator:a153e447124946743272c156ee40e7024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3037fa770c7f3c634359852d1e6578dd"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1ObservationPool.html">ObservationPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a3037fa770c7f3c634359852d1e6578dd">createObservationPool</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="separator:a3037fa770c7f3c634359852d1e6578dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9255f8536dc82bdbbf22e9d2f8b20da9"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1SearchStrategy.html">SearchStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a9255f8536dc82bdbbf22e9d2f8b20da9">createSearchStrategy</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="separator:a9255f8536dc82bdbbf22e9d2f8b20da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aad90d25bafab33624da97a61fc8546"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1EstimationStrategy.html">EstimationStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a7aad90d25bafab33624da97a61fc8546">createEstimationStrategy</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="separator:a7aad90d25bafab33624da97a61fc8546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670f91cb5cf3fc5b44be21ddfe7ecace"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a670f91cb5cf3fc5b44be21ddfe7ecace">createRootHistoricalData</a> ()</td></tr>
<tr class="separator:a670f91cb5cf3fc5b44be21ddfe7ecace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a047dea9be5fd302e30456dc13e490"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#af2a047dea9be5fd302e30456dc13e490">createSerializer</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="separator:af2a047dea9be5fd302e30456dc13e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract class representing a black-box POMDP model for use by the ABT solver.</p>
<p>The key methods are:</p>
<ul>
<li><a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c">sampleAnInitState()</a> - samples a new state from the initial belief.</li>
<li><a class="el" href="classsolver_1_1Model.html#afaefbb5cafd6984d16d0e7972e96befd">isTerminal()</a> - returns true iff the given state is terminal.</li>
<li><a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">generateStep()</a> - the key method representing the generative model; basically, it does (s, a) =&gt; (o, r, s')</li>
<li><a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818">applyChanges()</a> - applies changes to the model, and interfaces with the <a class="el" href="classsolver_1_1Solver.html">Solver</a> in order to determine how the policy is affected by the model changes.</li>
<li><a class="el" href="classsolver_1_1Model.html#a40bf7b0167216caaa37dbc5e79273a8b">generateParticles()</a> - these two methods define an explicit particle filtering approach, which allows the ABT algorithm to replenish its particles if the simple act of generating histories has not generated a sufficient number of particles for the current belief. The default implementation is quite general, but also relatively slow as it uses rejection sampling. Custom implementations should be provided for efficiency.</li>
<li><a class="el" href="classsolver_1_1Model.html#a080de609bc622ed1b2985a9c73cca392">getHeuristicFunction()</a> - this defines a heuristic function that will be applied to the end of a history sequence that did not reach a terminal state. By default this is simply a function that returns zero.</li>
</ul>
<p>For the purposes of more subtle generation, ABT allows for a more incremental approach to the generative model. In particular, we introduce optional "transition parameters" (y), which can serve the following key purposes:</p>
<ul>
<li>Encompassing any and all "randomness" that features in a state transition. This has two key advantages:<ul>
<li>When changing histories, we can minimize the number of histories that "diverge" from the original path.</li>
<li>This can also be used for various variance reduction techniques, which are well documented in the literature.</li>
</ul>
</li>
<li>Storing intermediate information about the generative calculations that would otherwise be relatively expensive to calculate.</li>
</ul>
<p>The generative model is therefore further broken down into the following methods; some of these parameters are optional and nullptr can be used for those values if they are not in use. In the summary below, optional parameters are surrounded by square brackets []. <a class="el" href="classsolver_1_1Model.html#ab63a02a646be252ec1bd3b2c6c1d9f14">generateTransition()</a> - (s, a) =&gt; [y] <a class="el" href="classsolver_1_1Model.html#a3e1fb5d2be61c81088c5ea575c8ae30e">generateNextState()</a> - (s, a, [y]) =&gt; s' <a class="el" href="classsolver_1_1Model.html#ae480df8a207b5fb68cdcc1b17b40768b">generateObservation()</a> - ([s], a, [y], s') =&gt; o <a class="el" href="classsolver_1_1Model.html#a8baf600ecf5379e0f9e2c0db86c62c34">generateReward()</a> - (s, a, [y], [s']) =&gt; r </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97a038e67b7bbb59ed2a0d7b33c470d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">solver::Model::Model </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomGenerator *&#160;</td>
          <td class="paramname"><em>randGen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="structsolver_1_1Options.html">Options</a> &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classsolver_1_1Model.html">Model</a> with the given name, random engine, and the given configuration settings.</p>
<p>Note that the options passed in will most typically be a subclass of the base <a class="el" href="structsolver_1_1Options.html">Options</a> class, which allows for problem-specific configuration settings in a convenient way. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaccf7e6bae8558086cf276017c9a9818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Model::applyChanges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1ModelChange.html">ModelChange</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a number of changes to the model, and (if provided) to the given solver.</p>
<p>This is the core method that is used for the <a class="el" href="classsolver_1_1Model.html">Model</a> to inform the <a class="el" href="classsolver_1_1Solver.html">Solver</a> of which states are affected, and hence need to be updated in whichever history sequences they occur. This should be done via the <a class="el" href="classsolver_1_1Solver.html">Solver</a>'s <a class="el" href="classsolver_1_1StatePool.html">StatePool</a> and <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a>.</p>
<p>Since handling of changes is not mandatory, this method does nothing by default. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a3675c790d995c45744f6e302b8610a35">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#aee78581d756decfeb7a7f8584151a8ff">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a153e447124946743272c156ee40e7024"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a>&gt; solver::Model::createActionPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classsolver_1_1ActionPool.html">ActionPool</a>, which manages actions and creates ActionMappings, for the given solver.</p>
<p>No default implementation is given, because there is no simple, general-purpose action mapping class. This is because the way in which actions are selected within the search tree depends strongly on the way in which the action space is specified.</p>
<p>However, for most purposes the EnumeratedActionMapping class should work well. This requires that the actions be enumerated [0, ..., nActions - 1], and that each action must be able to return its action number. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a52f7b73c5f81b116d3fca37bc5c80ece">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a6fadc5231a38f5d332c8a9dc761a441e">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a7aad90d25bafab33624da97a61fc8546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1EstimationStrategy.html">EstimationStrategy</a> &gt; solver::Model::createEstimationStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a strategy for estimating the value of belief nodes, for backprop, for the given solver.</p>
<p>The default approach is to simply take the average value of the estimated Q(s, a) values, weighted by the number of visits for each action - this is equivalent to the average value of all of the histories that go through this node.</p>
<p>This is a general-purpose approach which should converge for any problem as long as it is used with a search strategy that uses a UCB-like algorithm. </p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#a1769cce7f4d1d801bf0a8912d660df52">shared::ModelWithProgramOptions</a>.</p>

</div>
</div>
<a class="anchor" id="a680abcdce70007452d7148e571d417d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1HistoryCorrector.html">HistoryCorrector</a> &gt; solver::Model::createHistoryCorrector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classsolver_1_1HistoryCorrector.html">HistoryCorrector</a> for this <a class="el" href="classsolver_1_1Model.html">Model</a>.</p>
<p>By default, this simply makes an instance of <a class="el" href="classsolver_1_1DefaultHistoryCorrector.html">DefaultHistoryCorrector</a>, which should work for pretty much all POMDP problems. </p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#a736662f55f6f8887e50f643d4fadbd80">shared::ModelWithProgramOptions</a>.</p>

</div>
</div>
<a class="anchor" id="a3037fa770c7f3c634359852d1e6578dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1ObservationPool.html">ObservationPool</a> &gt; solver::Model::createObservationPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classsolver_1_1ObservationPool.html">ObservationPool</a>, which manages observations and creates ObservationMappings, for the given solver.</p>
<p>The default implementation is <a class="el" href="classsolver_1_1DiscreteObservationPool.html">DiscreteObservationPool</a>, which stores the observations for each <a class="el" href="classsolver_1_1ActionNode.html">ActionNode</a> in a hashtable. This should be effective for any problem with a discrete observation space. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#aac57f2b88b70d6998eed6bfe48e41ba1">rocksample::RockSampleModel</a>.</p>

</div>
</div>
<a class="anchor" id="a670f91cb5cf3fc5b44be21ddfe7ecace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> &gt; solver::Model::createRootHistoricalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the historical data for the root node.</p>
<p>By default this returns a null pointer, as the <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> interface is optional. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a192d1c04c9ead1ebfd393c9b1a443510">rocksample::RockSampleModel</a>.</p>

</div>
</div>
<a class="anchor" id="a9255f8536dc82bdbbf22e9d2f8b20da9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1SearchStrategy.html">SearchStrategy</a> &gt; solver::Model::createSearchStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a search strategy for use by the given solver.</p>
<p>The default strategy is simply a combination of UCB, in conjunction with applying the default heuristic function implemented by this model to the resulting state as soon as a new node in the policy tree is reached.</p>
<p>Note that the default strategy simply uses a UCB coefficient of 1.0 - if you need to change this coefficient value, simply override this method. </p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#a87a62ae1676eb8c4d7186dda8fa4a97f">shared::ModelWithProgramOptions</a>.</p>

</div>
</div>
<a class="anchor" id="af2a047dea9be5fd302e30456dc13e490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> &gt; solver::Model::createSerializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> for the given solver.</p>
<p>By default this returns a null pointer. However, if you require serialization of the state of an ABT solver, you must implement a custom <a class="el" href="classsolver_1_1Serializer.html">Serializer</a> which will properly serialize the various clases you have implemented as part of your POMDP model. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a827e08611510470f8a8b0023deeae460">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ae11259dc1b4cf3426459ffd1d6885a84">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="aa9099de4b2b73a8b55a916a5ba827401"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> &gt; solver::Model::createStateIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a>, which manages searching for states that have been used in a <a class="el" href="classsolver_1_1StatePool.html">StatePool</a>.</p>
<p>By default, this method uses an R*-Tree, as implemented in libspatialindex, in order to allow range-based queries for the states. </p>

</div>
</div>
<a class="anchor" id="ae98d2be0d9d93c7400163df7c40115a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Model::drawEnv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the environment map (independent of the current state or belief) onto the given output stream.</p>
<p>Does nothing by default. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a7ceb9c80046ef33d7325f05bf2c5b94f">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a888ccb2307023d84485eace5f0a1ab8c">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a48bfb5cef2839f7e20f670e37f0b643b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void solver::Model::drawSimulationState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> const *&#160;</td>
          <td class="paramname"><em>belief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the current belief and/or the actual current state in the context of the overall map onto the given output stream.</p>
<p>Does nothing by default. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a6ffb03c676d9738381124d43717ae655">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a3950e8a4df86b9bebd131337c396572d">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a3e1fb5d2be61c81088c5ea575c8ae30e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classsolver_1_1Point.html">State</a>&gt; solver::Model::generateNextState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates the next state, based on the state and action, and, if used, the transition parameters. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#ab632e79e36a246f393e759e3e0bc83c9">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a0453e43cf10a8ff15d98aa40c8abe908">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="ae480df8a207b5fb68cdcc1b17b40768b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classsolver_1_1Point.html">Observation</a>&gt; solver::Model::generateObservation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates an observation, given the action and resulting next state; optionally, the previous state and the transition parameters can also be used. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a1fff87dc9eb30bd1450a16b467445ba6">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#a790d25b10b9b46b1e5d735e1576b2f40">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a40bf7b0167216caaa37dbc5e79273a8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">State</a> &gt; &gt; solver::Model::generateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *&#160;</td>
          <td class="paramname"><em>previousBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Observation</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsolver_1_1Point.html">State</a> const * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>previousParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates new state particles based on the state particles of the previous node, as well as on the action and observation.</p>
<p>The default implementation uses rejection sampling, but this can be overridden to provide a more efficient implementation. </p>

</div>
</div>
<a class="anchor" id="a0dc0aa58463c5da7385824e08a242dc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">State</a> &gt; &gt; solver::Model::generateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *&#160;</td>
          <td class="paramname"><em>previousBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Observation</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates new state particles based only on the previous action and observation, assuming a poorly-informed prior over previous states.</p>
<p>This should only be used if the previous belief turns out to be incompatible with the current observation.</p>
<p>The default implementation uses rejection sampling, but this can be overridden to provide a more efficient implementation. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a7f0c264da6a90d17b477547b0772589d">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#acc9c7e67068e6a1a9b34c6b0912085f0">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a8baf600ecf5379e0f9e2c0db86c62c34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double solver::Model::generateReward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const *&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the reward for the given state, action; optionally this also includes transition parameters and the next state - if they aren't being used it is OK to use nullptr for those inputs. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a10878f20df5e89acc1cdb878e9eb663b">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#aed6c8471934ef7c719c315f694ff6770">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="ac935e5b653acc3a19dd5bc963bf4a14d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsolver_1_1Model_1_1StepResult.html">StepResult</a> solver::Model::generateStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a full <a class="el" href="structsolver_1_1Model_1_1StepResult.html">StepResult</a>, including the next state, an observation, and the reward, as well as any transition parameters used.</p>
<p>For convenience, the action taken is also included in the result, as well as a flag for whether or not the resulting next state is terminal. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a83ddd528d6cce7ef94acb1e20bea5290">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ad102851658bd8a0998fe05c50fb17473">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="ab63a02a646be252ec1bd3b2c6c1d9f14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> &gt; solver::Model::generateTransition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates the parameters for a next-state transition, if any are being used.</p>
<p>This method is optional - the default implementation simply returns nullptr. </p>

</div>
</div>
<a class="anchor" id="a080de609bc622ed1b2985a9c73cca392"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesolver.html#ab9e1b50ecb46556312c91f9349be3966">Heuristic</a> solver::Model::getHeuristicFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the function that approximates the value of a history entry based on the history and/or an estimate using a single state.</p>
<p>By default, this is simply a function that returns zero for every state.</p>
<p>The default implementation simply returns zero. </p>

<p>Reimplemented in <a class="el" href="classshared_1_1ModelWithProgramOptions.html#af4955a7a3b8a15ee138ff0194dc8c1de">shared::ModelWithProgramOptions</a>.</p>

</div>
</div>
<a class="anchor" id="ad5eb987c371dd354c7cf2816aae8999b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string solver::Model::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of this problem. </p>

</div>
</div>
<a class="anchor" id="a7d9177e4ab34e4d512f0a5b8ac9a822a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsolver_1_1Options.html">Options</a> const * solver::Model::getOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the configuration options for this model. </p>

</div>
</div>
<a class="anchor" id="a20afccd61c8f55833ce560efd58e9801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomGenerator * solver::Model::getRandomGenerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the random number generator used by this model. </p>

</div>
</div>
<a class="anchor" id="a458b46cd30555b7cca121f383831a2af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1Point.html">Action</a> &gt; solver::Model::getRolloutAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1HistoryEntry.html">HistoryEntry</a> const *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> const *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a rollout action to be use, which can be based on the current state, the current belief, and/or the history.</p>
<p>By default, this method simply returns nullptr, because rollouts are not used at all by the default search strategy - instead it simply uses the heuristic function.</p>
<p>Providing the <a class="el" href="classsolver_1_1HistoryEntry.html">HistoryEntry</a> allows access to the history sequence and belief associated with the history entry, allowing for more intelligent POMDP-aware heuristics.</p>
<p>Providing the <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> allows for convenient history-based rollout policies that can be efficiently calculated per belief node rather than requiring explicit calculation from the entire history sequence.</p>
<p>Providing the current state also allows for optimistic rollout strategies based on perfect information.</p>
<p>Optional; not implemented. </p>

<p>Reimplemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a43c68168bde5bf7edea9562be2f37825">rocksample::RockSampleModel</a>.</p>

</div>
</div>
<a class="anchor" id="afaefbb5cafd6984d16d0e7972e96befd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool solver::Model::isTerminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Point.html">State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true iff the given state is terminal. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a484a616e2df44e9d9a94c655c4c6e119">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ac4ab766ca6879f285b91bb5fce68b5e0">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a2e62295cded9ac6e59ac46bbe98ba70c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classsolver_1_1Point.html">State</a>&gt; solver::Model::sampleAnInitState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Samples an initial state from the initial belief. </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#afc7b64bbf56a9a0a95543d57e9a2f739">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#ae255eae8542528670096bd06736f88fa">tag::TagModel</a>.</p>

</div>
</div>
<a class="anchor" id="a4c8b0b629913785f450aa07740b3eda1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classsolver_1_1Point.html">State</a>&gt; solver::Model::sampleStateUniform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Samples a state uniformly at random from all states (this is required because it is used by the default implementation of the second generateParticles method). </p>

<p>Implemented in <a class="el" href="classrocksample_1_1RockSampleModel.html#a1fb7d313cb42574393fcb71a7636e7fa">rocksample::RockSampleModel</a>, and <a class="el" href="classtag_1_1TagModel.html#aa2296948f89dc6dab8d886ed7582926e">tag::TagModel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/solver/abstract-problem/<a class="el" href="Model_8hpp_source.html">Model.hpp</a></li>
<li>src/solver/abstract-problem/Model.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 1 2014 15:47:13 for ABT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
