<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ABT: tag::TagModel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ABT
   </div>
   <div id="projectbrief">An online approximate POMDP solver that can adapt to changes in the POMDP model.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tag</b></li><li class="navelem"><a class="el" href="classtag_1_1TagModel.html">TagModel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtag_1_1TagModel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tag::TagModel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for tag::TagModel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtag_1_1TagModel.png" usemap="#tag::TagModel_map" alt=""/>
  <map id="tag::TagModel_map" name="tag::TagModel_map">
<area href="classshared_1_1ModelWithProgramOptions.html" title="A partial implementation of Model allowing for text-based parsing of various advanced search options..." alt="shared::ModelWithProgramOptions" shape="rect" coords="0,56,207,80"/>
<area href="classsolver_1_1Model.html" title="An abstract class representing a black-box POMDP model for use by the ABT solver. ..." alt="solver::Model" shape="rect" coords="0,0,207,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2ff0e25829ea7e6a0bc378409a9d1b75"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a2ff0e25829ea7e6a0bc378409a9d1b75">TagCellType</a> : int { <b>EMPTY</b> = 0, 
<b>WALL</b> = -1
 }</td></tr>
<tr class="memdesc:a2ff0e25829ea7e6a0bc378409a9d1b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cells are either empty or walls.  <a href="classtag_1_1TagModel.html#a2ff0e25829ea7e6a0bc378409a9d1b75">More...</a><br/></td></tr>
<tr class="separator:a2ff0e25829ea7e6a0bc378409a9d1b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a817a699f69f84ebfbdc2a476bef0cdab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a817a699f69f84ebfbdc2a476bef0cdab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TagModel</b> (<a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *randGen, std::unique_ptr&lt; <a class="el" href="structtag_1_1TagOptions.html">TagOptions</a> &gt; options)</td></tr>
<tr class="separator:a817a699f69f84ebfbdc2a476bef0cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2968e0951fcabe6e73315f477a67ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee2968e0951fcabe6e73315f477a67ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TagModel</b> (<a class="el" href="classtag_1_1TagModel.html">TagModel</a> const &amp;)=delete</td></tr>
<tr class="separator:aee2968e0951fcabe6e73315f477a67ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67de1e281a1d34fbc58bf58464f0d21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab67de1e281a1d34fbc58bf58464f0d21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TagModel</b> (<a class="el" href="classtag_1_1TagModel.html">TagModel</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab67de1e281a1d34fbc58bf58464f0d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253dde601e31ae11cfc73bdc72dd66d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a253dde601e31ae11cfc73bdc72dd66d3"></a>
<a class="el" href="classtag_1_1TagModel.html">TagModel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classtag_1_1TagModel.html">TagModel</a> const &amp;)=delete</td></tr>
<tr class="separator:a253dde601e31ae11cfc73bdc72dd66d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b03299487c0e949bf9269b623f9fa8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b03299487c0e949bf9269b623f9fa8f"></a>
<a class="el" href="classtag_1_1TagModel.html">TagModel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classtag_1_1TagModel.html">TagModel</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a1b03299487c0e949bf9269b623f9fa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e481b3e251e8ec1f8ce35e15e2be162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e481b3e251e8ec1f8ce35e15e2be162"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>getNRows</b> () const </td></tr>
<tr class="separator:a7e481b3e251e8ec1f8ce35e15e2be162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31a3f22d8273838eaa5efed638e0e22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af31a3f22d8273838eaa5efed638e0e22"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>getNCols</b> () const </td></tr>
<tr class="separator:af31a3f22d8273838eaa5efed638e0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4d936b36bbeee915951ddacbd606d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#acf4d936b36bbeee915951ddacbd606d2">makeMdpSolver</a> ()</td></tr>
<tr class="memdesc:acf4d936b36bbeee915951ddacbd606d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the MDP solver for this model.  <a href="#acf4d936b36bbeee915951ddacbd606d2">More...</a><br/></td></tr>
<tr class="separator:acf4d936b36bbeee915951ddacbd606d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d602d814bd050bad1821db8168b0627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtag_1_1TagMdpSolver.html">TagMdpSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a0d602d814bd050bad1821db8168b0627">getMdpSolver</a> ()</td></tr>
<tr class="memdesc:a0d602d814bd050bad1821db8168b0627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MDP solver for this model.  <a href="#a0d602d814bd050bad1821db8168b0627">More...</a><br/></td></tr>
<tr class="separator:a0d602d814bd050bad1821db8168b0627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae255eae8542528670096bd06736f88fa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#ae255eae8542528670096bd06736f88fa">sampleAnInitState</a> () override</td></tr>
<tr class="memdesc:ae255eae8542528670096bd06736f88fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples an initial state from the initial belief.  <a href="#ae255eae8542528670096bd06736f88fa">More...</a><br/></td></tr>
<tr class="separator:ae255eae8542528670096bd06736f88fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132f33203b738ffe681701e0d65607e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a132f33203b738ffe681701e0d65607e7">sampleStateUninformed</a> () override</td></tr>
<tr class="memdesc:a132f33203b738ffe681701e0d65607e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an untagged state uniformly at random.  <a href="#a132f33203b738ffe681701e0d65607e7">More...</a><br/></td></tr>
<tr class="separator:a132f33203b738ffe681701e0d65607e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ab766ca6879f285b91bb5fce68b5e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#ac4ab766ca6879f285b91bb5fce68b5e0">isTerminal</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;state) override</td></tr>
<tr class="memdesc:ac4ab766ca6879f285b91bb5fce68b5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given state is terminal.  <a href="#ac4ab766ca6879f285b91bb5fce68b5e0">More...</a><br/></td></tr>
<tr class="separator:ac4ab766ca6879f285b91bb5fce68b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0453e43cf10a8ff15d98aa40c8abe908"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a0453e43cf10a8ff15d98aa40c8abe908">generateNextState</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">solver::TransitionParameters</a> const *) override</td></tr>
<tr class="memdesc:a0453e43cf10a8ff15d98aa40c8abe908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the next state, based on the state and action, and, if used, the transition parameters.  <a href="#a0453e43cf10a8ff15d98aa40c8abe908">More...</a><br/></td></tr>
<tr class="separator:a0453e43cf10a8ff15d98aa40c8abe908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790d25b10b9b46b1e5d735e1576b2f40"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">solver::Observation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a790d25b10b9b46b1e5d735e1576b2f40">generateObservation</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const *, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">solver::TransitionParameters</a> const *, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;nextState) override</td></tr>
<tr class="memdesc:a790d25b10b9b46b1e5d735e1576b2f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an observation, given the action and resulting next state; optionally, the previous state and the transition parameters can also be used.  <a href="#a790d25b10b9b46b1e5d735e1576b2f40">More...</a><br/></td></tr>
<tr class="separator:a790d25b10b9b46b1e5d735e1576b2f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6c8471934ef7c719c315f694ff6770"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#aed6c8471934ef7c719c315f694ff6770">generateReward</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;action, <a class="el" href="classsolver_1_1TransitionParameters.html">solver::TransitionParameters</a> const *, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const *) override</td></tr>
<tr class="memdesc:aed6c8471934ef7c719c315f694ff6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reward for the given state, action; optionally this also includes transition parameters and the next state - if they aren't being used it is OK to use nullptr for those inputs.  <a href="#aed6c8471934ef7c719c315f694ff6770">More...</a><br/></td></tr>
<tr class="separator:aed6c8471934ef7c719c315f694ff6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad102851658bd8a0998fe05c50fb17473"><td class="memItemLeft" align="right" valign="top">virtual Model::StepResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#ad102851658bd8a0998fe05c50fb17473">generateStep</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;action) override</td></tr>
<tr class="memdesc:ad102851658bd8a0998fe05c50fb17473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a full StepResult, including the next state, an observation, and the reward, as well as any transition parameters used.  <a href="#ad102851658bd8a0998fe05c50fb17473">More...</a><br/></td></tr>
<tr class="separator:ad102851658bd8a0998fe05c50fb17473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee78581d756decfeb7a7f8584151a8ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#aee78581d756decfeb7a7f8584151a8ff">applyChanges</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1ModelChange.html">solver::ModelChange</a> &gt;&gt; const &amp;changes, <a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *solver) override</td></tr>
<tr class="memdesc:aee78581d756decfeb7a7f8584151a8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a number of changes to the model, and (if provided) to the given solver.  <a href="#aee78581d756decfeb7a7f8584151a8ff">More...</a><br/></td></tr>
<tr class="separator:aee78581d756decfeb7a7f8584151a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa839c3d655b18b9da8b4d6c759fcb1d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa839c3d655b18b9da8b4d6c759fcb1d8"></a>
virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generateParticles</b> (<a class="el" href="classsolver_1_1BeliefNode.html">solver::BeliefNode</a> *previousBelief, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;action, <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">solver::Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const * &gt; const &amp;previousParticles) override</td></tr>
<tr class="separator:aa839c3d655b18b9da8b4d6c759fcb1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9c7e67068e6a1a9b34c6b0912085f0"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#acc9c7e67068e6a1a9b34c6b0912085f0">generateParticles</a> (<a class="el" href="classsolver_1_1BeliefNode.html">solver::BeliefNode</a> *previousBelief, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;action, <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">solver::Observation</a> const &amp;obs, long nParticles) override</td></tr>
<tr class="memdesc:acc9c7e67068e6a1a9b34c6b0912085f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates new state particles based only on the previous action and observation, assuming a poorly-informed prior over previous states.  <a href="#acc9c7e67068e6a1a9b34c6b0912085f0">More...</a><br/></td></tr>
<tr class="separator:acc9c7e67068e6a1a9b34c6b0912085f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e55c4be39f66780bba619c43118f60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a30e55c4be39f66780bba619c43118f60">dispCell</a> (<a class="el" href="classtag_1_1TagModel.html#a2ff0e25829ea7e6a0bc378409a9d1b75">TagCellType</a> cellType, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a30e55c4be39f66780bba619c43118f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a single cell of the map.  <a href="#a30e55c4be39f66780bba619c43118f60">More...</a><br/></td></tr>
<tr class="separator:a30e55c4be39f66780bba619c43118f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888ccb2307023d84485eace5f0a1ab8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a888ccb2307023d84485eace5f0a1ab8c">drawEnv</a> (std::ostream &amp;os) override</td></tr>
<tr class="memdesc:a888ccb2307023d84485eace5f0a1ab8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the environment map (independent of the current state or belief) onto the given output stream.  <a href="#a888ccb2307023d84485eace5f0a1ab8c">More...</a><br/></td></tr>
<tr class="separator:a888ccb2307023d84485eace5f0a1ab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950e8a4df86b9bebd131337c396572d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a3950e8a4df86b9bebd131337c396572d">drawSimulationState</a> (<a class="el" href="classsolver_1_1BeliefNode.html">solver::BeliefNode</a> const *belief, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;state, std::ostream &amp;os) override</td></tr>
<tr class="memdesc:a3950e8a4df86b9bebd131337c396572d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the current belief and/or the actual current state in the context of the overall map onto the given output stream.  <a href="#a3950e8a4df86b9bebd131337c396572d">More...</a><br/></td></tr>
<tr class="separator:a3950e8a4df86b9bebd131337c396572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585af8903fe05abf48d4c4031248b78f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a585af8903fe05abf48d4c4031248b78f"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultHeuristicValue</b> (<a class="el" href="classsolver_1_1HistoryEntry.html">solver::HistoryEntry</a> const *entry, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const *state, <a class="el" href="classsolver_1_1HistoricalData.html">solver::HistoricalData</a> const *data) override</td></tr>
<tr class="separator:a585af8903fe05abf48d4c4031248b78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c491167b3ca2f58fc68404ebcc061a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7c491167b3ca2f58fc68404ebcc061a"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>getUpperBoundHeuristicValue</b> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;state)</td></tr>
<tr class="separator:aa7c491167b3ca2f58fc68404ebcc061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269fc0c166b24d714f713200498c7ec1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a269fc0c166b24d714f713200498c7ec1"></a>
virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1DiscretizedPoint.html">solver::DiscretizedPoint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAllActionsInOrder</b> ()</td></tr>
<tr class="separator:a269fc0c166b24d714f713200498c7ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fadc5231a38f5d332c8a9dc761a441e"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1ActionPool.html">solver::ActionPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#a6fadc5231a38f5d332c8a9dc761a441e">createActionPool</a> (<a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *solver) override</td></tr>
<tr class="memdesc:a6fadc5231a38f5d332c8a9dc761a441e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ActionPool, which manages actions and creates ActionMappings, for the given solver.  <a href="#a6fadc5231a38f5d332c8a9dc761a441e">More...</a><br/></td></tr>
<tr class="separator:a6fadc5231a38f5d332c8a9dc761a441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11259dc1b4cf3426459ffd1d6885a84"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1Serializer.html">solver::Serializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag_1_1TagModel.html#ae11259dc1b4cf3426459ffd1d6885a84">createSerializer</a> (<a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *solver) override</td></tr>
<tr class="memdesc:ae11259dc1b4cf3426459ffd1d6885a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Serializer for the given solver.  <a href="#ae11259dc1b4cf3426459ffd1d6885a84">More...</a><br/></td></tr>
<tr class="separator:ae11259dc1b4cf3426459ffd1d6885a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classshared_1_1ModelWithProgramOptions"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classshared_1_1ModelWithProgramOptions')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classshared_1_1ModelWithProgramOptions.html">shared::ModelWithProgramOptions</a></td></tr>
<tr class="memitem:a45a7e8829260bd07ed0c8559cfc14af3 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45a7e8829260bd07ed0c8559cfc14af3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a45a7e8829260bd07ed0c8559cfc14af3">ModelWithProgramOptions</a> (std::string problemName, <a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *randGen, std::unique_ptr&lt; <a class="el" href="structshared_1_1SharedOptions.html">SharedOptions</a> &gt; options)</td></tr>
<tr class="memdesc:a45a7e8829260bd07ed0c8559cfc14af3 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classshared_1_1ModelWithProgramOptions.html" title="A partial implementation of Model allowing for text-based parsing of various advanced search options...">ModelWithProgramOptions</a> with the given problem name, the given RandomGenerator, and the given set of options. <br/></td></tr>
<tr class="separator:a45a7e8829260bd07ed0c8559cfc14af3 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698dd68f057ff397ff459852b09261bc inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a698dd68f057ff397ff459852b09261bc">registerGeneratorParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1StepGeneratorFactory.html">solver::StepGeneratorFactory</a> &gt;&gt; &gt; parser)</td></tr>
<tr class="memdesc:a698dd68f057ff397ff459852b09261bc inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given parser for instances of StepGeneratorFactory with the given name string, allowing it to be parsed at runtime.  <a href="#a698dd68f057ff397ff459852b09261bc">More...</a><br/></td></tr>
<tr class="separator:a698dd68f057ff397ff459852b09261bc inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd562dcb89aa52bb961da596d87e5298 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#abd562dcb89aa52bb961da596d87e5298">registerHeuristicParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; <a class="el" href="namespacesolver.html#a2652743b2b118d001615cc27ed0ce636">solver::HeuristicFunction</a> &gt; &gt; parser)</td></tr>
<tr class="memdesc:abd562dcb89aa52bb961da596d87e5298 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given parser for heuristic functions with the given name string, allowing it to be parsed at runtime.  <a href="#abd562dcb89aa52bb961da596d87e5298">More...</a><br/></td></tr>
<tr class="separator:abd562dcb89aa52bb961da596d87e5298 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f231aedb7621488862639be958168b inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a77f231aedb7621488862639be958168b">registerSearchParser</a> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1SearchStrategy.html">solver::SearchStrategy</a> &gt;&gt; &gt; parser)</td></tr>
<tr class="memdesc:a77f231aedb7621488862639be958168b inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given parser for search strategies with the given name string, allowing it to be parsed at runtime.  <a href="#a77f231aedb7621488862639be958168b">More...</a><br/></td></tr>
<tr class="separator:a77f231aedb7621488862639be958168b inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5272a8d764373f3aaafd08234ea0d7e inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5272a8d764373f3aaafd08234ea0d7e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>registerEstimationParser</b> (std::string name, std::unique_ptr&lt; <a class="el" href="classshared_1_1Parser.html">Parser</a>&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1EstimationStrategy.html">solver::EstimationStrategy</a> &gt;&gt; &gt; parser)</td></tr>
<tr class="separator:ac5272a8d764373f3aaafd08234ea0d7e inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a62ae1676eb8c4d7186dda8fa4a97f inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1SearchStrategy.html">solver::SearchStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a87a62ae1676eb8c4d7186dda8fa4a97f">createSearchStrategy</a> (<a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *solver) override</td></tr>
<tr class="memdesc:a87a62ae1676eb8c4d7186dda8fa4a97f inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a search strategy for use by the given solver.  <a href="#a87a62ae1676eb8c4d7186dda8fa4a97f">More...</a><br/></td></tr>
<tr class="separator:a87a62ae1676eb8c4d7186dda8fa4a97f inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1769cce7f4d1d801bf0a8912d660df52 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1EstimationStrategy.html">solver::EstimationStrategy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a1769cce7f4d1d801bf0a8912d660df52">createEstimationStrategy</a> (<a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *solver) override</td></tr>
<tr class="memdesc:a1769cce7f4d1d801bf0a8912d660df52 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a strategy for estimating the value of belief nodes, for backprop, for the given solver.  <a href="#a1769cce7f4d1d801bf0a8912d660df52">More...</a><br/></td></tr>
<tr class="separator:a1769cce7f4d1d801bf0a8912d660df52 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736662f55f6f8887e50f643d4fadbd80 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1HistoryCorrector.html">solver::HistoryCorrector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a736662f55f6f8887e50f643d4fadbd80">createHistoryCorrector</a> (<a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *solver) override</td></tr>
<tr class="memdesc:a736662f55f6f8887e50f643d4fadbd80 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a HistoryCorrector for this Model.  <a href="#a736662f55f6f8887e50f643d4fadbd80">More...</a><br/></td></tr>
<tr class="separator:a736662f55f6f8887e50f643d4fadbd80 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce114391f7b099d906ddb90d0b38c5 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacesolver.html#a2652743b2b118d001615cc27ed0ce636">solver::HeuristicFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshared_1_1ModelWithProgramOptions.html#a25ce114391f7b099d906ddb90d0b38c5">getHeuristicFunction</a> () finaloverride</td></tr>
<tr class="memdesc:a25ce114391f7b099d906ddb90d0b38c5 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function that approximates the value of a history entry based on the history and/or an estimate using a single state.  <a href="#a25ce114391f7b099d906ddb90d0b38c5">More...</a><br/></td></tr>
<tr class="separator:a25ce114391f7b099d906ddb90d0b38c5 inherit pub_methods_classshared_1_1ModelWithProgramOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsolver_1_1Model"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsolver_1_1Model')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsolver_1_1Model.html">solver::Model</a></td></tr>
<tr class="memitem:a97a038e67b7bbb59ed2a0d7b33c470d0 inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a97a038e67b7bbb59ed2a0d7b33c470d0">Model</a> (std::string name, <a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *randGen, std::unique_ptr&lt; <a class="el" href="structsolver_1_1Options.html">Options</a> &gt; options)</td></tr>
<tr class="memdesc:a97a038e67b7bbb59ed2a0d7b33c470d0 inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classsolver_1_1Model.html" title="An abstract class representing a black-box POMDP model for use by the ABT solver. ...">Model</a> with the given name, random engine, and the given configuration settings.  <a href="#a97a038e67b7bbb59ed2a0d7b33c470d0">More...</a><br/></td></tr>
<tr class="separator:a97a038e67b7bbb59ed2a0d7b33c470d0 inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20afccd61c8f55833ce560efd58e9801 inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a080b7731c061f9bafcf79d5e2f0c388a">RandomGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a20afccd61c8f55833ce560efd58e9801">getRandomGenerator</a> () const </td></tr>
<tr class="memdesc:a20afccd61c8f55833ce560efd58e9801 inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the random number generator used by this model.  <a href="#a20afccd61c8f55833ce560efd58e9801">More...</a><br/></td></tr>
<tr class="separator:a20afccd61c8f55833ce560efd58e9801 inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9177e4ab34e4d512f0a5b8ac9a822a inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsolver_1_1Options.html">Options</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a7d9177e4ab34e4d512f0a5b8ac9a822a">getOptions</a> () const </td></tr>
<tr class="memdesc:a7d9177e4ab34e4d512f0a5b8ac9a822a inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the configuration options for this model.  <a href="#a7d9177e4ab34e4d512f0a5b8ac9a822a">More...</a><br/></td></tr>
<tr class="separator:a7d9177e4ab34e4d512f0a5b8ac9a822a inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eb987c371dd354c7cf2816aae8999b inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ad5eb987c371dd354c7cf2816aae8999b">getName</a> () const </td></tr>
<tr class="memdesc:ad5eb987c371dd354c7cf2816aae8999b inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this problem.  <a href="#ad5eb987c371dd354c7cf2816aae8999b">More...</a><br/></td></tr>
<tr class="separator:ad5eb987c371dd354c7cf2816aae8999b inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a02a646be252ec1bd3b2c6c1d9f14 inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1TransitionParameters.html">TransitionParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#ab63a02a646be252ec1bd3b2c6c1d9f14">generateTransition</a> (<a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const &amp;state, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action)</td></tr>
<tr class="memdesc:ab63a02a646be252ec1bd3b2c6c1d9f14 inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the parameters for a next-state transition, if any are being used.  <a href="#ab63a02a646be252ec1bd3b2c6c1d9f14">More...</a><br/></td></tr>
<tr class="separator:ab63a02a646be252ec1bd3b2c6c1d9f14 inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bf7b0167216caaa37dbc5e79273a8b inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a40bf7b0167216caaa37dbc5e79273a8b">generateParticles</a> (<a class="el" href="classsolver_1_1BeliefNode.html">BeliefNode</a> *previousBelief, <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> const &amp;action, <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">Observation</a> const &amp;obs, long nParticles, std::vector&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const * &gt; const &amp;previousParticles)</td></tr>
<tr class="memdesc:a40bf7b0167216caaa37dbc5e79273a8b inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates new state particles based on the state particles of the previous node, as well as on the action and observation.  <a href="#a40bf7b0167216caaa37dbc5e79273a8b">More...</a><br/></td></tr>
<tr class="separator:a40bf7b0167216caaa37dbc5e79273a8b inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458b46cd30555b7cca121f383831a2af inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">Action</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a458b46cd30555b7cca121f383831a2af">getRolloutAction</a> (<a class="el" href="classsolver_1_1HistoryEntry.html">HistoryEntry</a> const *entry, <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">State</a> const *state, <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> const *data)</td></tr>
<tr class="memdesc:a458b46cd30555b7cca121f383831a2af inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a rollout action to be use, which can be based on the current state, the current belief, and/or the history.  <a href="#a458b46cd30555b7cca121f383831a2af">More...</a><br/></td></tr>
<tr class="separator:a458b46cd30555b7cca121f383831a2af inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9099de4b2b73a8b55a916a5ba827401 inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1StateIndex.html">StateIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#aa9099de4b2b73a8b55a916a5ba827401">createStateIndex</a> ()</td></tr>
<tr class="memdesc:aa9099de4b2b73a8b55a916a5ba827401 inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsolver_1_1StateIndex.html" title="An interface class for storing states and looking them up in custom ways. ">StateIndex</a>, which manages searching for states that have been used in a <a class="el" href="classsolver_1_1StatePool.html" title="A class to hold all of the states encountered by the ABT algorithm. ">StatePool</a>.  <a href="#aa9099de4b2b73a8b55a916a5ba827401">More...</a><br/></td></tr>
<tr class="separator:aa9099de4b2b73a8b55a916a5ba827401 inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3037fa770c7f3c634359852d1e6578dd inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1ObservationPool.html">ObservationPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a3037fa770c7f3c634359852d1e6578dd">createObservationPool</a> (<a class="el" href="classsolver_1_1Solver.html">Solver</a> *solver)</td></tr>
<tr class="memdesc:a3037fa770c7f3c634359852d1e6578dd inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classsolver_1_1ObservationPool.html" title="An interface class which is a factory for creating observation mappings. ">ObservationPool</a>, which manages observations and creates ObservationMappings, for the given solver.  <a href="#a3037fa770c7f3c634359852d1e6578dd">More...</a><br/></td></tr>
<tr class="separator:a3037fa770c7f3c634359852d1e6578dd inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670f91cb5cf3fc5b44be21ddfe7ecace inherit pub_methods_classsolver_1_1Model"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classsolver_1_1HistoricalData.html">HistoricalData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsolver_1_1Model.html#a670f91cb5cf3fc5b44be21ddfe7ecace">createRootHistoricalData</a> ()</td></tr>
<tr class="memdesc:a670f91cb5cf3fc5b44be21ddfe7ecace inherit pub_methods_classsolver_1_1Model"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the historical data for the root node.  <a href="#a670f91cb5cf3fc5b44be21ddfe7ecace">More...</a><br/></td></tr>
<tr class="separator:a670f91cb5cf3fc5b44be21ddfe7ecace inherit pub_methods_classsolver_1_1Model"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a33426b29fbb4262a307191aa3ba87bd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33426b29fbb4262a307191aa3ba87bd1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TagObservation</b></td></tr>
<tr class="separator:a33426b29fbb4262a307191aa3ba87bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88ef14884d02d6aa4733016a6c9cc70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae88ef14884d02d6aa4733016a6c9cc70"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TagMdpSolver</b></td></tr>
<tr class="separator:ae88ef14884d02d6aa4733016a6c9cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="TagModel_8hpp_source.html#l00056">56</a> of file <a class="el" href="TagModel_8hpp_source.html">TagModel.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a2ff0e25829ea7e6a0bc378409a9d1b75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classtag_1_1TagModel.html#a2ff0e25829ea7e6a0bc378409a9d1b75">tag::TagModel::TagCellType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cells are either empty or walls. </p>

<p>Definition at line <a class="el" href="TagModel_8hpp_source.html#l00069">69</a> of file <a class="el" href="TagModel_8hpp_source.html">TagModel.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aee78581d756decfeb7a7f8584151a8ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tag::TagModel::applyChanges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsolver_1_1ModelChange.html">solver::ModelChange</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a number of changes to the model, and (if provided) to the given solver. </p>
<p>This is the core method that is used for the Model to inform the Solver of which states are affected, and hence need to be updated in whichever history sequences they occur. This should be done via the Solver's StatePool and StateIndex.</p>
<p>Since handling of changes is not mandatory, this method does nothing by default. However, if you do implement it, you must also implement <a class="el" href="classtag_1_1TagModel.html#a0453e43cf10a8ff15d98aa40c8abe908" title="Generates the next state, based on the state and action, and, if used, the transition parameters...">generateNextState()</a>, <a class="el" href="classtag_1_1TagModel.html#a790d25b10b9b46b1e5d735e1576b2f40" title="Generates an observation, given the action and resulting next state; optionally, the previous state a...">generateObservation()</a>, and <a class="el" href="classtag_1_1TagModel.html#aed6c8471934ef7c719c315f694ff6770" title="Returns the reward for the given state, action; optionally this also includes transition parameters a...">generateReward()</a>. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#aaccf7e6bae8558086cf276017c9a9818">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00323">323</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6fadc5231a38f5d332c8a9dc761a441e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1ActionPool.html">solver::ActionPool</a> &gt; tag::TagModel::createActionPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an ActionPool, which manages actions and creates ActionMappings, for the given solver. </p>
<p>No default implementation is given, because there is no simple, general-purpose action mapping class. This is because the way in which actions are selected within the search tree depends strongly on the way in which the action space is specified.</p>
<p>However, for most purposes the EnumeratedActionMapping class should work well. This requires that the actions be enumerated [0, ..., nActions - 1], and that each action must be able to return its action number. </p>

<p>Implements <a class="el" href="classsolver_1_1Model.html#a153e447124946743272c156ee40e7024">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00643">643</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae11259dc1b4cf3426459ffd1d6885a84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsolver_1_1Serializer.html">solver::Serializer</a> &gt; tag::TagModel::createSerializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1Solver.html">solver::Solver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Serializer for the given solver. </p>
<p>By default this returns a null pointer. However, if you require serialization of the state of an ABT solver, you must implement a custom Serializer which will properly serialize the various clases you have implemented as part of your POMDP model. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#af2a047dea9be5fd302e30456dc13e490">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00646">646</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30e55c4be39f66780bba619c43118f60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tag::TagModel::dispCell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtag_1_1TagModel.html#a2ff0e25829ea7e6a0bc378409a9d1b75">TagCellType</a>&#160;</td>
          <td class="paramname"><em>cellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays a single cell of the map. </p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00520">520</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a888ccb2307023d84485eace5f0a1ab8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tag::TagModel::drawEnv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the environment map (independent of the current state or belief) onto the given output stream. </p>
<p>Does nothing by default. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#ae98d2be0d9d93c7400163df7c40115a8">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00534">534</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3950e8a4df86b9bebd131337c396572d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tag::TagModel::drawSimulationState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">solver::BeliefNode</a> const *&#160;</td>
          <td class="paramname"><em>belief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the current belief and/or the actual current state in the context of the overall map onto the given output stream. </p>
<p>Does nothing by default. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#a48bfb5cef2839f7e20f670e37f0b643b">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00544">544</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0453e43cf10a8ff15d98aa40c8abe908"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt; tag::TagModel::generateNextState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">solver::TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the next state, based on the state and action, and, if used, the transition parameters. </p>
<p>This method is only mandatory if you implement the <a class="el" href="classtag_1_1TagModel.html#aee78581d756decfeb7a7f8584151a8ff" title="Applies a number of changes to the model, and (if provided) to the given solver. ">applyChanges()</a> method. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#a73fc7fe3f7ebe845604fac46adc0383b">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00295">295</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a790d25b10b9b46b1e5d735e1576b2f40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">solver::Observation</a> &gt; tag::TagModel::generateObservation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">solver::TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an observation, given the action and resulting next state; optionally, the previous state and the transition parameters can also be used. </p>
<p>This method is only mandatory if you implement the <a class="el" href="classtag_1_1TagModel.html#aee78581d756decfeb7a7f8584151a8ff" title="Applies a number of changes to the model, and (if provided) to the given solver. ">applyChanges()</a> method. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#a40e63ec3d653c9e42120e8690a311d4c">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00301">301</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc9c7e67068e6a1a9b34c6b0912085f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt; &gt; tag::TagModel::generateParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsolver_1_1BeliefNode.html">solver::BeliefNode</a> *&#160;</td>
          <td class="paramname"><em>previousBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a8daf06feba3570a40cd98d779ba03f0f">solver::Observation</a> const &amp;&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates new state particles based only on the previous action and observation, assuming a poorly-informed prior over previous states. </p>
<p>This should only be used if the previous belief turns out to be incompatible with the current observation.</p>
<p>The default implementation uses rejection sampling, but this can be overridden to provide a more efficient implementation. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#a0dc0aa58463c5da7385824e08a242dc5">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00490">490</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed6c8471934ef7c719c315f694ff6770"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double tag::TagModel::generateReward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsolver_1_1TransitionParameters.html">solver::TransitionParameters</a> const *&#160;</td>
          <td class="paramname"><em>transitionParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const *&#160;</td>
          <td class="paramname"><em>nextState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reward for the given state, action; optionally this also includes transition parameters and the next state - if they aren't being used it is OK to use nullptr for those inputs. </p>
<p>This method is only mandatory if you implement the <a class="el" href="classtag_1_1TagModel.html#aee78581d756decfeb7a7f8584151a8ff" title="Applies a number of changes to the model, and (if provided) to the given solver. ">applyChanges()</a> method. </p>

<p>Reimplemented from <a class="el" href="classsolver_1_1Model.html#a57f002206fa228bf82cf0fb67037d7c4">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00278">278</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad102851658bd8a0998fe05c50fb17473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsolver_1_1Model_1_1StepResult.html">solver::Model::StepResult</a> tag::TagModel::generateStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a4d49455281fc7c00cded44247277bb94">solver::Action</a> const &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a full StepResult, including the next state, an observation, and the reward, as well as any transition parameters used. </p>
<p>For convenience, the action taken is also included in the result, as well as a flag for whether or not the resulting next state is terminal. </p>

<p>Implements <a class="el" href="classsolver_1_1Model.html#ac935e5b653acc3a19dd5bc963bf4a14d">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00308">308</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d602d814bd050bad1821db8168b0627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtag_1_1TagMdpSolver.html">TagMdpSolver</a>* tag::TagModel::getMdpSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the MDP solver for this model. </p>

<p>Definition at line <a class="el" href="TagModel_8hpp_source.html#l00088">88</a> of file <a class="el" href="TagModel_8hpp_source.html">TagModel.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ab766ca6879f285b91bb5fce68b5e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tag::TagModel::isTerminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> const &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the given state is terminal. </p>

<p>Implements <a class="el" href="classsolver_1_1Model.html#afaefbb5cafd6984d16d0e7972e96befd">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00153">153</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf4d936b36bbeee915951ddacbd606d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tag::TagModel::makeMdpSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up the MDP solver for this model. </p>

<p>Definition at line <a class="el" href="TagModel_8hpp_source.html#l00083">83</a> of file <a class="el" href="TagModel_8hpp_source.html">TagModel.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae255eae8542528670096bd06736f88fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt; tag::TagModel::sampleAnInitState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Samples an initial state from the initial belief. </p>

<p>Implements <a class="el" href="classsolver_1_1Model.html#a2e62295cded9ac6e59ac46bbe98ba70c">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00143">143</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a132f33203b738ffe681701e0d65607e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespacesolver.html#a46d2c881ad1e2c4057e34efc1344fbf5">solver::State</a> &gt; tag::TagModel::sampleStateUninformed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an untagged state uniformly at random. </p>

<p>Implements <a class="el" href="classsolver_1_1Model.html#a7c3fd2691ae717aa5cdf61fe32269f5c">solver::Model</a>.</p>

<p>Definition at line <a class="el" href="TagModel_8cpp_source.html#l00147">147</a> of file <a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/problems/tag/<a class="el" href="TagModel_8hpp_source.html">TagModel.hpp</a></li>
<li>src/problems/tag/<a class="el" href="TagModel_8cpp_source.html">TagModel.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2014 18:18:32 for ABT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
